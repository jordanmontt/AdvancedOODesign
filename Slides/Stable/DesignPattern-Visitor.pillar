{
	"title":"Visitor",
	"subtitle":"",
	"author":"",
	"slidesid":""
}


${slide:title=Goal}$

- Visitor
- Discussions



${slide:title=Visitor's intent}$

- Represent an operation to be performed on the elements of an object structure in a class separate from the elements themselves. 

- Visitor lets you define a new operation ""without changing the classes of the elements"" on which it operates.


${slide:title=Visitor's design}$

+.>file://figures/Visitor-Design.png|width=60+


${slide:title=Visitor + Composite}$

- A visitor requires a structure to perform different actions based on the kind of element
- Perfect match with a composite

${slide:title=Example: basic arithmetic expressions}$

- Supports one kind of number, and has +, *, (, )
- We want to evaluate expressions, and print them

Evaluating
[[[
1 + (3 * 2)
gives 7
]]]

Printing
[[[
+1*32
]]]

${slide:title=Expression hierarchy}$

+.>file://figures/Visitor-SimpleExpressionHierarchy.png|width=50+

${slide:title=Some expressions}$

1
[[[
ENumber value: 1
]]]

(3 \* 2)
[[[
Times left: (ENumber value: 3) right: (ENumber value: 2)
]]]

1 \+ (3 \* 2)
[[[
Plus
	left: (ENumber value: 1)
	right: (Times left: (ENumber value: 3) right: (ENumber value: 2))
]]]

Of course in Pharo we can just extend ==Number== so no need of ==ENumber== ==value:== but this is a detail

${slide:title=Operation implementation}$

Two solutions:
- add methods for evaluating, printing, ... on ==Expression== and its subclasses
- create a Visitor, add the visit methods on ==Expression== and its subclasses, and implement visitors for evaluation, printing, ...

${slide:title=First design: behavior in the domain}$

+.>file://figures/Visitor-ExpressionTree.png|width=50+


${slide:title=First design analysis}$

What if we need a stack to print well the expressions?
- Should we put it in the expressions even if this is related only to print?

Why should we mix the information about the treatment of items and items themselves?
- What if we need a table for mathematical expression only for the LaTeX generation?
- What if we need a table for mathematical expression only for the RDF generation?




${slide:title=Second design: Expression Visitor}$

A visitor separates a treatment from the data structure (Composite) it applies to.

+.>file://figures/Visitor-ExpressionsVisitor.png|width=45+

${slide:title=Expression Visitor: Using double dispatch}$

+.>file://figures/Visitor-ExpressionsVisitor.png|width=90+


${slide:title=Evaluator Visitor}$

[[[
Evaluator >> visitNumber: aNumber
   ^ aNumber value
]]]

[[[
Evaluator >> visitPlus: anExpression
   | l r |
   l := anExpression left acceptVisitor: self.
   r := anExpression right acceptVisitor: self.
   ^ l + r
]]]

[[[
Evaluator >> visitTimes: anExpression
   | l r |
   l := anExpression left acceptVisitor: self.
   r := anExpression right acceptVisitor: self.
   ^ l * r 
]]]

${slide:title=Invoking the Visitor}$

[[[
Evaluator new evaluate: 
	(Plus 
		left: (ENumber value: 1) 
		right: (Times left: (ENumber value: 3) right: (ENumber value: 2)))
> 7 
]]]

[[[
Evaluator >> evaluate: anExpression
   ^ anExpression acceptVisitor: self
]]]	

${slide:title=Printer}$

[[[
Visitor subclass: #Printer
   iv: 'stream level'
]]]
[[[
Printer >> visitNumber: aNumber
     stream nextPutAll: aNumber value asString
]]]

[[[
Printer >> visitPlus: anExpression
    stream nextPutAll: '+'.
    anExpression left acceptVisitor: self.
    anExpression right acceptVisitor: self.
]]]
[[[
Printer >> visitPlus: anExpression
    stream nextPutAll: '*'.
    anExpression left acceptVisitor: self.
    anExpression right acceptVisitor: self.
]]]

${slide:title=Expression Visitor analysis}$

- Each visitor knows what to do for a number, a plus and times operation
- Each visitor manages it own specific state
- Each visitor is independent of other ones


${slide:title=Visitor: another look at it}$

- Pluggable distributed recursive treatment of a composite structure

[[[
Printer >> visitPlus: anExpression
    stream nextPutAll: '*'.
    anExpression left acceptVisitor: self.
    anExpression right acceptVisitor: self.
]]]


${slide:title=Stepping back: key logic}$

The double dispatch is the key point
- The Visitor knows the elementary operations (e.g., evaluating a plus, a minus, a value)
- The items mentions to the Visitor how they want to be visited

+.>file://figures/Visitor-ExpressionsVisitor.png|width=60+


${slide:title=Stepping back: a basic trolling question}$

Some people may tell you that Visitor is not OO because Visitor externalizes behavior out of objects.
- Yes operations applied on objects are defined outside the objects.
- Let us think:
-- How much extra behavior and extra state mixed for nothing are you ready to pay?
-- Do you want to package multiple behaviors separately?
- If you have a lot of orthogonal treatments, then better separate them

${slide:title=When to use a Visitor}$

- Whenever you have a number of items on which you have to perform a number of actions

Examples:
- Parse tree (ProgramNode) uses a visitor for
-- the compilation (emitting code on CodeStream), 
-- pretty printing, syntax hilighting
-- different analysis pass, 
-- rotten green test analysis
- Rendering documents (Document) in different formats
-- nodes expansion, HTML, LaTeX, ...

