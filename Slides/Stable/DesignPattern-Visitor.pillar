{
	"title":"Visitor",
	"subtitle":"",
	"author":"",
	"slidesid":""
}


${slide:title=Goal}$

- Visitor
- Discussions



${slide:title=Visitor's intent}$

- Represent an operation to be performed on the elements of an object structure in a class separate from the elements themselves. 

- Visitor lets you define a new operation ""without changing the classes of the elements"" on which it operates.


${slide:title=Visitor's design}$

+.>file://figures/Visitor-Design.png|width=50+


${slide:title=Visitor + Composite}$

A visitor requires a structure to perform different actions based on the kind of element

Perfect plays with a composite

${slide:title=Example: basic arithmetic expressions}$

- Supports one kind of number, and has +, *, (, )
- We want to evaluate expressions, and print them

Evaluating
[[[
1 + (3 * 2)
gives 7
]]]

Printing
[[[
+1*32
]]]

${slide:title=Expression hierarchy}$

+.>file://figures/Visitor-SimpleExpressionHierarchy.png|width=50+

${slide:title=Some expressions}$

1
[[[
ENumber value: 1
]]]

(3 \* 2)
[[[
Times left: (ENumber value: 3) right: (ENumber value: 2)
]]]

1 \+ (3 \* 2)
[[[
Plus
	left: (ENumber value: 1)
	right: (Times left: (ENumber value: 3) right: (ENumber value: 2))
]]]

Of course in Pharo we can just extend ==Number== so no need of ==ENumber== ==value:== but this is a detail

${slide:title=Operation implementation}$

Two solutions:
- add methods for evaluating, printing, ... on ==Expression== and its subclasses
- create a Visitor, add the visit methods on ==Expression== and its subclasses, and implement visitors for evaluation, printing, ...

${slide:title=First design: behavior in the domain}$

+.>file://figures/Visitor-ExpressionTree.png|width=50+


${slide:title=First design analysis}$

- What if we need a stack to print well the expressions?
-- Should we put it in the expressions even if this is related only to print?

- What if we need a table for mathematical expression only for the LaTeX exporter?
Why should we mix the information about the treatment of items and items themselves?

${slide:title=First design: Expression Visitor}$

+.>file://figures/Visitor-ExpressionsVisitor.png|width=90+

${slide:title=Expression Visitor analysis}$

Each visitor knows what to do for a number, a plus and times operation

${slide:title=Evaluator Visitor}$

[[[
Evaluator >> visitNumber: aNumber
   ^ aNumber value
]]]

[[[
Evaluator >> visitPlus: anExpression
   | l r |
   l := anExpression left acceptVisitor: self.
   r := anExpression right acceptVisitor: self.
   ^ l + r
]]]

[[[
Evaluator >> visitTimes: anExpression
   | l r |
   l := anExpression left acceptVisitor: self.
   r := anExpression right acceptVisitor: self.
   ^ l * r 
]]]

${slide:title=Invoking the Visitor}$

[[[
Evaluator new evaluate: 
	(Plus 
		left: (ENumber value: 1) 
		right: (Times left: (ENumber value: 3) right: (ENumber value: 2)))
> 7 
]]]

[[[
Evaluator >> evaluate: anExpression
   ^ anExpression acceptVisitor: self
]]]	

${slide:title=Printer}$

[[[
Visitor subclass: #Printer
   iv: 'stream level'
]]]
[[[
Printer >> visitNumber: aNumber
     stream nextPutAll: aNumber value asString
]]]

[[[
Printer >> visitPlus: anExpression
    stream nextPutAll: '+'.
    anExpression left acceptVisitor: self.
    anExpression right acceptVisitor: self.
]]]
[[[
Printer >> visitPlus: anExpression
    stream nextPutAll: '*'.
    anExpression left acceptVisitor: self.
    anExpression right acceptVisitor: self.
]]]


${slide:title=Visitor: another look at it}$

- Pluggable distributed recursive treatment of a composite structure

add a diagram here

${slide:title=Stepping back: key logic}$

The double dispatch is the key point
- The Visitor knows the elementary operations 
- The items declare how they want to be visited

+.>file://figures/Visitor-ExpressionsVisitor.png|width=60+


${slide:title=Stepping back: the basic trolling question}$

Some people may tell you that it is not OO because visitor externalize behavior.
- Yes operations applied on objects are defined outside the objects.
- Let us think:
-- how much extra behavior and extra state mixed for nothing are you ready to get
-- do you want to package multiple behavior separately (yes in Pharo we have method extension but state is not well managed)
-- if you have a lot of orthogonal treatments, then better separate them






${slide:title=Example in Pillar}$


