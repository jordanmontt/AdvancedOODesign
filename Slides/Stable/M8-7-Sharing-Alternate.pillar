{
    "title":"More about sharing",
    "slideid":"M8-S7"
}


${slide:title=Goals}$

We saw
- Shared variable to share between all instances of a class and instances of its subclasses
- Mixing instance variable and share variable: we get sharing by default and possible instance based customization
- Flyweigth
Here is another variation on that theme taken from Bloc


${slide:title=BlElement}$

==BlElement== is the basic graphical element
- has many properties
- ==background==, ==border==, ==clipChildren==, ==elevation==, ==geometry==, ==compositingMode==, ==effect==, ==focusability==, ==focused==, ==mouseCursor==, ==opacity==, ==outskirts==, ==visibility==

${slide:title=BlElement property example}$

[[[
BlElement >> border
	^ visuals border
]]]

[[[
BlElement >> clipChildren
	^ visuals clipChildren
]]]


${slide:title=BlElement}$

[[[
BlElement >> border: aBlBorder
	"Change my border and invalidate me. aBlBorder can be created using BlBorderBuilder. Raises BlElementBorderChangedEvent"
	self border = aBlBorder
		ifTrue: [ ^ self ].
	visuals := visuals border: aBlBorder.
	self geometry releaseStrokedBoundsCache.
	self eventDispatcher dispatchBorderChanged.
	self invalidate
]]]



${slide:title=Overview}$

+>file://figures/SharableBloc.pdf|width=90+

${slide:title=BlElementVisuals and setup}$
	 
- Kind of a pattern to make sure that many default values can be shared by default
- And modifications to these defaults on a per instance level
- But without one instance variable per prorperty

${slide:title=BlElementVisuals}$

- Define API and default values

[[[
Object << #BlElementVisuals
	sharedVariables: { #DefaultBorder . #DefaultBackground . #DefaultGeometry . #DefaultVisibility };
	package: 'Bloc'
]]]

[[[
BlElementVisuals >> defaultBackground
	^ DefaultBackground
]]]

[[[
BlElementVisuals >> background: aBlBackground
	^ self subclassResponsibility
]]]



${slide:title=BlDefaultVisuals}$

- ==BlDefaultVisuals== a kind of singleton that holds many default values to be shared between multiples elements.
- Getters access default shared value
[[[
BlDefaultVisuals >> background
	^ self defaultBackground
]]]


${slide:title=BlDefaultVisuals: setters are key}$

==BlDefaultVisuals== is kind of  read only because setters are executed, they do not modify but
create and return a new instance of ==BlCustomVisuals==.

[[[
BlDefaultVisuals >> background: aBlBackground
	"Change the background and return new visuals to be used instead of previous one"

	^ BlCustomVisuals new background: aBlBackground
]]]

${slide:title=BlCustomVisuals}$

Instance specific customization

[[[
BlElementVisuals << #BlCustomVisuals
	slots: { #geometry . #border . #background . #outskirts .  #effect ... };
	package: 'Bloc'
]]]

[[[
BlCustomVisuals >> background: aBlBackground
	background := aBlBackground
]]]

- ==BlCustomVisuals== stored in place of ==BlDefaultVisuals== singleton to accumulate modifications of the default. 
- I accumulate modifications because contrary to ==BlDefaultVisuals== my setters modify myself.


${slide:title=There is a catch}$

Users should always store the result of the setters sent to a visuals

[[[
BlElement >> background: aBlBackground
	"Change my background to a given one.
	Raises BlElementBackgroundChangedEvent."

	...

	visuals := visuals background: aNewBackground.

	...
]]]

- It is not really nice to hijack setter semantics this way.

${slide:title=What is the difference with the TypeTable/typeTable}$

- Group different values in a single object
- Avoid to have one instance variable per customisation point
- But still we have instance-based and sharing