{
    "title":"About Registrations",
    "subtitle":"",
    "author":""
}

${slide:title=Goal}$

- Thinking about system dynamic
- Impact of dynamic registration


${slide:title=Classes can queried}$

Remember...
[[[
Parser >> documentClasses
   ^ DocumentItem allSubclasses
      sorted: [ :class1 :class2 | class1 priority < class2 priority ]
]]]
[[[
Parser >> parse: line
    self documentClasses
        detect: [ :subclass |
            (subclass canParse: line)
                ifTrue: [ ^ subclass newFromLine: line ] ]
]]]

${slide:title=Registration for 'Free'}$

Pros: 
- Each time a new class is loaded it is taken into account

Cons: 
- We do it ""all the time for nothing""
- We are querying the system for nothing

${slide:title=Solution 1: Explicit static list}$

[[[
Parser >> documentClasses
   ^ { Section . List . Paragraph }
      sorted: [ :class1 :class2 | class1 priority < class2 priority ]
]]]


${slide:title=Statically sorting the list}$

In fact we could precompute priority too

[[[
Parser >> documentClasses
	^ { Section . Paragraph . List }
]]]

Pros: 
- Do not have to query all the classes all the time

Cons:
- Watch out because we may not want to list explicitly class to avoid dependencies to other packages


${slide:title=Solution 2: Explicit registration mechanism}$

E.g., classes can explicit register to the parser

[[[
Section class >> initialize
	Parser registerClass: self
]]]

[[[
List class >> initialize
	Parser registerClass: self
]]]

[[[
Parser >> documentClasses
	^ RegisteredClasses
]]]

${slide:title=A registration mechanism supports extension}$

[[[
Extra class >> initialize
	Parser registerClass: self
]]]

- External classes can also register
- Without introducing unwanted dependency
- Without scanning all the classes of the system

${slide:title=Conclusion}$

- XXX subclasses is a cool pattern 
- But it has a cost! 
- Design is about tradeoffs

