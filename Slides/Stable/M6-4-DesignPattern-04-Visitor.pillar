{
	"title":"Visitor",
	"subtitle":"Modular and extensible first class actions",
	"slidesid":"M6S4"
}


${slide:title=Goals}$

- Studying examples
- Understanding the Visitor design pattern
- Discussions on pros and cons

${slide:title=Example: basic arithmetic expressions}$


Imagine a simple mathematical system

[[[
Plus
	left: (ENumber value: 1)
	right: (Times left: (ENumber value: 3) right: (ENumber value: 2))
]]]

Remarks:
- In this example, we reify everything
- In Pharo, no need to wrap numbers with ==ENumber== because can extend ==Number==
-- this is a detail

${slide:title=Basic arithmetic expressions as Composite}$

${columns}$

${column:width=45}$

An expression is represented by a Composite with numbers and operations
(see Lecture on Composite)

${column:width=45}$

+.>file://figures/Visitor-ExpressionHierarchy.pdf|width=90+

${endColumns}$


${slide:title=Some expressions}$

1
[[[
ENumber value: 1
]]]

(3 \* 2)
[[[
Times left: (ENumber value: 3) right: (ENumber value: 2)
]]]

1 \+ (3 \* 2)
[[[
Plus
	left: (ENumber value: 1)
	right: (Times left: (ENumber value: 3) right: (ENumber value: 2))
]]]




${slide:title=Operations on the expressions}$

We want two operations on expressions:

- Evaluate
[[[
1 + (3 * 2)
> 7
]]]

- Print (in Polish notation)
[[[
1 + (3 * 2)
> +1*32
]]]


${slide:title=First design: behavior defined in the domain}$

+.>file://figures/Visitor-ExpressionHierarchyWithBehavior.pdf|width=40+


${slide:title=First design: behavior defined in the domain}$

[[[
ENumber >> evaluate
	^ value
]]]

[[[
EPlus >> evaluate
   ^  left evaluate + right evaluate
]]]

[[[
ENumber >> print
	stream nextPutAll: value asString
]]]

[[[
EPlus >> print
...
]]]

${slide:title=First design: analysis}$

- Some operations require some state
-- e.g. a stack is needed to print expressions in infix notation
- Where should we define such state?
-- ""in"" the expression classes?
-- even if this is ""only"" related to print?

Should we ""mix"" the state of operations on items with the items themselves?

${slide:title=Overview of a real system}$

The Pillar Pharo library:
- a core hierarchy of 50 classes (document model)
- export to LaTeX (two versions)
- export to HTML
- export to Beamer
- export to ASCIIdoc, Markdown, Microdown
- transform trees for expansion
- code checkers
- ...

${slide:title=First design: conclusion}$

Putting all the behavior inside domain objects:

- ""Blows up"" the class API / state / methods
- ""Mixes"" concerns
- Is ""not modular"": we cannot have ""one"" operation only
- ""Prevents extension"": adding a new behavior requires changing the domain

${slide:title=Essence of the Visitor design pattern}$

A ""Visitor"":
- ""Represents"" an operation
- ""Decouples"" this operation from the domain objects it applies to (separate class)
- Supports ""modularity"" (separate package)
- Supports ""extension""
-- We define ""once"" a set of messages (e.g., ==visitX==) in domain objects
-- Then, new visitors (operations) are easy to define ""without changing domain objects"" it operates on


${slide:title=Alternate Visitor-based design}$

+.>file://figures/Visitor-ExpressionsVisitorPrinciple.pdf|width=70+


${slide:title=Visitor \+ Composite}$

A visitor requires a structure to perform different actions based on the kind of element
- ""Perfect"" match with a composite
- ""Uses double dispatch""

A visitor separates a treatment from the data structure (Composite) it applies to.

${slide:title=Based on double dispatch}$


Each composite element accepts a visitor and tell it how to visit it

[[[
X >> accept: aVisitor
	aVisitor visitX: self
]]]

Key to avoid terrible conditional checks



${slide:title=Example: Evaluator Visitor}$

[[[
Evaluator >> visitNumber: aNumber
   ^ aNumber value
]]]

[[[
Evaluator >> visitPlus: anExpression
   | l r |
   l := anExpression left acceptVisitor: self.
   r := anExpression right acceptVisitor: self.
   ^ l + r
]]]

[[[
Evaluator >> visitTimes: anExpression
   | l r |
   l := anExpression left acceptVisitor: self.
   r := anExpression right acceptVisitor: self.
   ^ l * r
]]]

${slide:title=Invoking the Visitor}$

[[[
expr := (EPlus
		left: (ENumber value: 1)
		right: (ETimes left: (ENumber value: 3) right: (ENumber value: 2))).
Evaluator new evaluate: expr.
> 7
]]]

[[[
Evaluator >> evaluate: anExpression
   ^ anExpression acceptVisitor: self
]]]

${slide:title=Example: Printer}$

[[[
Visitor << #Printer
    slots: { #stream. #level. }
]]]
[[[
Printer >> visitNumber: aNumber
    stream nextPutAll: aNumber value asString
]]]

[[[
Printer >> visitPlus: anExpression
    stream nextPutAll: '+'.
    anExpression left acceptVisitor: self.
    anExpression right acceptVisitor: self.
]]]
[[[
Printer >> visitTimes: anExpression
    stream nextPutAll: '*'.
    anExpression left acceptVisitor: self.
    anExpression right acceptVisitor: self.
]]]

${slide:title=Expression Visitor analysis}$

- Each visitor ""knows"" what to do for a number, a plus,  and times operation
- Each visitor manages its ""own specific"" state
- Each visitor is ""independent"" of other ones
- Double dispatch supports the decoupling

${slide:title=A protocol for extension}$

To extend a visitor:
- Define a class which has the expected API i.e., ==visitX== methods
- Apply the visitor to the structure


${slide:title=Stepping back: double dispatch is the key point}$

- The Visitor knows the elementary operations (e.g., evaluating a plus, a minus, and a value)
- The items mentions to the Visitor how ""they"" want to be visited

+.>file://figures/Visitor-ExpressionsVisitorPrinciple.pdf|width=60+


${slide:title=Imagine a tree of shapes}$

+.>file://figures/SimpleTree.pdf|width=40+

${slide:title=Each node will respond differently to a visit}$

+.>file://figures/SimpleTreeWithVisitMethods.pdf|width=60+

The visitor is then notified precisely with the corresponding node in argument

${slide:title=Visitor: another look at it}$

Visitor design provides a ""pluggable distributed recursive treatment"" of a composite structure
- ==acceptVisitor:== is recursively propagated on sub elements.
[[[
Printer >> visitPlus: anExpression
    stream nextPutAll: '*'.
    anExpression left acceptVisitor: self.
    anExpression right acceptVisitor: self.
]]]



${slide:title=When to use a Visitor}$

- Whenever you have a number of items on which you have to perform a number of actions

Examples:
- Parse tree (ProgramNode) uses a visitor for
-- the compilation (emitting code on CodeStream),
-- pretty printing, syntax hilighting
-- different analysis pass,
-- rotten green test analysis
- Rendering documents (Document) in different formats
-- nodes expansion, HTML, LaTeX, ...

${slide:title=When using a Visitor is challenging}$

Changing node elements
- If the elements of the composite ""change"", you will have to change ""all"" your visitors
- Problem known as the expression problems in statically-typed languages


${slide:title=Conclusion}$

""Pros:""
- Visitor is a good pattern
- It provides modular and extensible design
- Double dispatch makes it plug and play

""Cons:""
- Can look more complex
- It is not well adapted to changing structures

