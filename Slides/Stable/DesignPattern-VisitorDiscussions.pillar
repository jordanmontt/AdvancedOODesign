{
	"title":"Discussions about Visitor",
	"subtitle":"",
	"author":"S. Ducasse",
	"slidesid":""
}



${slide:title=Expression problem}$

${slide:title=Controlling the traversal}$

A visitor embeds a structure traversal
- There are different places where the traversal can be implemented:
-- in the visitors
-- in the items themselves

Usually the visitor is under control but may be the domain logic is more important. 

${slide:title=Visitor in control}$

+.>file://figures/Visitor-VisitorControl.png|width=80+


${slide:title=Items in control}$

+.>file://figures/Visitor-ItemControl.png|width=80+


${slide:title=Implementation: Visitor vs. class extension}$

Even if a language supports class extension (defining methods on a class from another package than the class package), using a Visitor is better because:
- Each Visitor encapsulates a complex operation
- Each Visitor has its own state

${slide:title=VisitMethods encode a context}$

- the granularity of visit methods has an impact on the hooks they offer
- ""visit*"" methods can be used to provide context

${slide:title=Example: visitTemporariesNode: vs. visitNode:}$

Compare
[[[
RBProgramNodeVisitor >> visitSequenceNode: aSequenceNode
	aSequenceNode temporaries do: [:each | self visitNode: each ].
	aSequenceNode statements do: [ :each | self visitNode: each ]
]]]

vs.

[[[
RBProgramNodeVisitor >> visitSequenceNode: aSequenceNode
	self visitTemporaryNodes: aSequenceNode temporaries.
	aSequenceNode statements do: [ :each | self visitNode: each ]
]]] 

[[[
RBProgramNodeVisitor >> visitTemporaryNodes: aNodeCollection

	^ aNodeCollection	do: [ :each | self visitTempDefinitionNode: each ]
]]]

[[[
RBProgramNodeVisitor >> visitTempDefinitionNode: aNode

	^ self visitNode: aNode
]]]

%${slide:title=Misopportunities}$

%+.>file://figures/Visitor-donodeStupid.png|width=80+

%${slide:title=Using messages as cases (again) }$

%+.>file://figures/Visitor-DonodeClever.png|width=90+

${slide:title=Using messages as cases (again) }$

Using ==visitTempDefinitionNode:== ensures the extender that such a method is not for all the variables but only for temporaries.
- No need to test
- No need to use a state updated by previous message sends
- Just override ==visitTempDefinitionNode:== and only be invoked on temporary definition


${slide:title=Building generic Visitors can be difficult}$

- Should we return always the results?
- Should collect the values on collection?

${slide:title=Should we promote collections as domain nodes?}$

- Open discussion....
- tell me what you think?


${slide:title=Visitor with reflection}$

+.>file://figures/VisitorReflectiveImplementation.png|width=90+


${slide:title=Visitor does not play well with node addition}$

- If your domain is growing or changing (new subclasses),
- You may end up having to change the visitors each time you introduce a new node in the composite and it can be tedious.



${slide:title=[Type] Do not use overloading for visit method}$

As a summary, overloading does not really work in Java and you will have to explicitly cast your visitor or use getClass everywhere.

- Better define method visitNumber(), visitPlus(), visitTimes()
- than visit()
Trust an expert :)

${slide:title=Conclusion}$

- Visitor can be tricky to master
-- use accept/visit vocabulary to really help you
- Visitor is nice for complex structure operations


