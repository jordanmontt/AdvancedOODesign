{
	"title":"Visitor Discussion",
	"subtitle":"",
	"author":"",
	"slidesid":""
}

${slide:title=Controlling the traversal}$

A visitor embeds a structure traversal
- Be default all the items should be reached
- There are different places where the traversal can be implemented:
-- in the visitors
-- in the items themselves

Usually the visitor is under control but may be the domain logic is more important. 

${slide:title=Visitor in control}$

+.>file://figures/Visitor-VisitorControl.png|width=80+


${slide:title=Items in control}$

+.>file://figures/Visitor-ItemControl.png|width=80+




${slide:title=VisitMethod encode context}$

- ""visit*"" methods can be used to let user extend functionality at fine granularity
- the granularity of visit methods has an impact on the hooks they offer

${slide:title=Example: visitTemporariesNode: vs. visitNode:}$

[[[
RBProgramNodeVisitor >> visitSequenceNode: aSequenceNode
	aSequenceNode temporaries do: [:each | self visitNode: each ].
	aSequenceNode statements do: [ :each | self visitNode: each ]
]]]

vs. 

[[[
RBProgramNodeVisitor >> visitSequenceNode: aSequenceNode
	self visitTemporaryNodes: aSequenceNode temporaries.
	aSequenceNode statements do: [ :each | self visitNode: each ]
]]] 

[[[
RBProgramNodeVisitor >> visitTemporaryNodes: aNodeCollection

	^ aNodeCollection	do: [ :each | self visitNode: each ]
]]]


%${slide:title=Misopportunities}$

%+.>file://figures/Visitor-donodeStupid.png|width=80+

%${slide:title=Using messages as cases (again) }$

%+.>file://figures/Visitor-DonodeClever.png|width=90+

${slide:title=Using messages as cases (again) }$

In this case using ==visitTemporaryNodes:==, it ensures the extender that such method is not for all the variables but only for temporaries.
- No need to test
- No need to get a state
- Just override ==visitTemporaryNodes:==


${slide:title=Generic Visitors are difficult to build}$

- Should we return always the results
- Should collect the values on collection?

${slide:title=Should we promote collections as nodes?}$

- Should we return always the results
- Should collect the values on collection?


${slide:title=Visitor with reflection}$

+.>file://figures/VisitorReflectiveImplementation.png|width=90+


${slide:title=When to use a Visitor}$

- Whenever you have a number of items on which you have to perform a number of actions
- When you ‘decouple’ the actions from the items.

Examples:
- Parse tree (ProgramNode) uses a visitor for the compilation (emitting code on CodeStream)
- Rendering documents (Document) in different formats

${slide:title=Visitor does not play well with new leaves}$

- If your domain is growing or changing (new subclasses),
- You may end up having to change the visitors each time you introduce a new leave in the composite
and it can be tedious.

${slide:title=Class extension}$

Even if a language supports class extension (defining methods on a class from another package than the class package), using a visitor is better because
- Each Visitor encapsulates a complex operation
- Each Visitor has its own state

${slide:title=[Type] Do not use overloading for visit method}$

As a summary, overloading does not really work in Java and you will have to explicitly cast your visitor or use getClass everywhere.

- Better define method visitNumber(), visitPlus(), visitTimes()
- than visit()
Trust an expert :)

${slide:title=Conclusion}$

- Visitor can be tricky to master
-- use accept/visit vocabulary to really help you
- Visitor is nice for complex structure operations


