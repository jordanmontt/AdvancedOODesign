{
    "title":"Customization degree of hooks",
    "subtitle":"Class vs. nstance hooks",
    "author":"StÃ©phane Ducasse"
}

${slide:title=Goal}$

- Thinking about hooks
- Granularity of hooks: class vs instance creation
- Do we or not customize instance creation
- Customisation of instance creation

${slide:title=Example: Introducing a hook}$

[[[
CHInterpreter >> visit...

	scope := CHClassScope new xxx
	...
	scope
]]]


${slide:title=Extract a class}$

[[[
CHInterpreter >> visit...

	scope := self classScopeClass new xxx
	...
	scope
]]]


[[[
CHInterpreter >> classScopeClass
	^ CHClassScope
]]]


${slide:title=A subclass can push a different class}$

[[[
CHInterpreter2 >> classScopeClass
	^ MyClassScope
]]]

- Ok it works!

${slide:title=Black box parametrization}$

[[[
Object < CHInterpreter
	slots: {#classScopeClass};
]]]

With an instance variable and a setter we can also get black box pametrization

[[[
CHInterpreter new
	classScopeClass: myClassScope;
	yourself
]]]



${slide:title=Analysis}$

- What if we have a more complex instantiation?
- And we want to encapsulate it and let the extender changes it.
- ==self classScopeClass new xxx== is not at a good granularity

[[[
CHInterpreter >> visit...

	scope := self classScopeClass new xxx
	...
	scope
]]]


${slide:title=Instance creation }$

[[[
CHInterpreter >> visit...

	scope := self newClassScope.
	...
	scope
]]]

[[[
CHInterpreter >> newClassScope

	^ self newClassScope xxx

]]]

${slide:title=Imagine}$

If you can only pass a class
- you cannot customize and access extra protocols
- you will have to do circumvoluted tricks (wrapping)

${slide:title=Passing object as context}$

[[[
CHInterpreter >> visit...

	scope := self newClassScopeNewFor: self
	...
	scope
]]]

- When we pass ==self==, we give the class the possibility to customise instantiation.


${slide:title=Conclusion}$

- Class hooks are ok 
- But think about others hooks


