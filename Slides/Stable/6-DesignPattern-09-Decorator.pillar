{
    "title":"Decorator Design Pattern",
    "author":"S. Ducasse"
}

${slide:title=Goals}$

- Decorator
- Think about API


${slide:title=Decorator}$

Attach additional responsibilities to an ovject **dynamically**. Decorators provide a flexible alternative to subclassing for extending functionality.


${slide:title=Example of Stream}$

ZnStreams are decorators of Streams.

[[[
ZnNewLineWriterStream
	on: (ZnCharacterWriteStream on: Stdio stdout encoding: 'utf8').
]]]

${slide:title=Another use}$

[[[
AbstractFileReference >> readStreamEncoded: anEncoding

	^ ZnCharacterReadStream
		on: self binaryReadStream
		encoding: anEncoding
]]]

- ==ZnCharacterReadStream== is decorating another stream with an encoding.

${slide:title=Implementation}$

[[[
WriteStream << #ZnNewLineWriterStream
	slots: { #stream . #cr . #lf . #previous . #lineEnding};
	package: 'Zinc-Character-Encoding-Core'
]]]

[[[
ZnNewLineWriterStream class >> on: aStream

	^ self basicNew
		initialize;
		stream: aStream;
		yourself
]]]

[[[
ZnNewLineWriterStream >> close
	stream close
]]]

[[[
ZnNewLineWriterStream >> flush
	^ stream flush
]]]


${slide:title=Example of Stream}$


[[[
testNextPut
	"Ensure that the line ends are written correctly"

	| expectedString stream crStream |

	expectedString := 'a', OSPlatform current lineEnding, 'b'.
	{ String cr.
		String lf.
		String crlf. } do: [ :lineEnd |
			stream := String new writeStream.
			crStream := ZnNewLineWriterStream on: stream.
			crStream
				<< 'a';
				<< lineEnd;
				<< 'b'.
			self assert: stream contents equals: expectedString ]
]]]


${slide:title=Example of Stream}$

[[[
ZnNewLineWriterStream >> nextPut: aCharacter
	"Write aCharacter to the receivers stream.
	Convert all line end combinations, i.e cr, lf, crlf, to the platform convention"

	(previous == cr and: [ aCharacter == lf ]) ifFalse: [
		(aCharacter == cr or: [ aCharacter == lf ]) ifTrue: 
			[ self newLine ]
		ifFalse:
			[ stream nextPut: aCharacter ] ].
	previous := aCharacter.
]]]


${slide:title=Analysis}$

- All decorators should have the same API
- ==close== ==flush== ==nextPut:== ==contents== ==next== ==atEnd== ==on:==
	
%${slide:title=Microdown builder in action}$

%+>file://figures/ClassComments.png|width=85+



${slide:title=About dynamically}$

Attach additional responsibilities to an ovject ""dynamically"". 

- The decorator is based on delegation: The decoration delegates the messages it does not specialize to the decoratee.
- To attach dynamic means that we should control the creation chain.


${slide:title=Commander and its decorators}$

+>file://figures/DecoratorWithSpec2.pdf|width=75+


${slide:title=Do not use reflection}$

- Do not use reflection to handle when decorators have different APIs.
-- This is a bad idea (tm)
-- Makes the design brittle

${slide:title=Conclusion}$

- Pay attention all the decorators should implement the same API
- Decorator is modular but within a common API