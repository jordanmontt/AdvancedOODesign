{
    "title" : "Message Sends are Plans for Reuse",
    "slidesid":"M3S2"
}

${slide:title=About this lecture}$

- Related to the "Essence of Dispatch" (sending a message is making a choice)
- Relevant to any object-oriented language
- Another essential aspect of object-oriented design

${slide:title=What you will learn}$

- Message sends are hooks for subclasses
- Message sends are places where subclasses code can be invoked

${slide:title=Let us start to reflect }$

Anecdotes
- ''I like big methods because I can see all the code''
- ''I do not like small methods''

Questions
- Why large methods leads to ''under-optimal'' design?
- Why writing small methods is a sign of good design?

${slide:title=Remember...}$

- a message send makes a choice
- a class hierarchy defines the choices
- ==self== ""always represents the receiver""
- method lookup starts in the ""class of the receiver"" (except for super)

+>file://figures/Design-FatVsDispatch.pdf|width=75+



${slide:title=An example}$

[[[
Node >> setWindowWithRatioForDisplay
   | defaultNodeSize |
   defaultNodeSize := mainCoordinate / maximizeViewRatio.
   self window add: (UINode new with: bandWidth * 55 / defaultWindowSize).
   previousNodeSize := defaultNodeSize.
]]]

What are the possible solutions to change the ==defaultNodeSize== formula in a subclass?


${slide:title=Bad solution: duplication}$

Duplicate the code in a subclass

[[[
Node subclass: NodeWithMargins
   ...
]]]

[[[
NodeWithMargins >> setWindowWithRatioForDisplay
  | defaultNodeSize |
  defaultNodeSize := (mainCoordinate / maximizeViewRatio) + 10.
  self window add: (UINode new with: bandWidth * 55 / defaultWindowSize).
  previousNodeSize := defaultNodeSize.
]]]

${slide:title=Avoid duplication}$

- Duplication is not a good practice:
-- duplication copies bugs
-- changing one copy requires changing others
- Note that in Java-like languages, using ==private== attributes makes duplication in subclasses impossible

${slide:title=Essence of a better solution}$

${columns}$

${column:width=60}$

- Define small methods
- Send messages
- Subclasses can override such methods

${column:width=40}$

+>file://figures/SelfIsDynamic.pdf|width=80+

${endColumns}$

${slide:title=Applying it on our example}$

We can refactor this:

[[[
Node >> setWindowWithRatioForDisplay
  | defaultNodeSize |
  defaultNodeSize := (mainCoordinate / maximizeViewRatio).
  self window add: (UINode new with: bandWidth * 55 / defaultWindowSize).
  previousNodeSize := defaultNodeSize.
]]]

into:

[[[
Node >> setWindowWithRatioForDisplay
   | defaultNodeSize |
   defaultNodeSize := self ratio.
   self window add: (UINode new with: bandWidth * 55 / defaultWindowSize).
   previousNodeSize := defaultNodeSize.
]]]

[[[
Node >> ratio
   ^ mainCoordinate / maximizeViewRatio
]]]


${slide:title=Subclasses can now reuse the superclass logic}$

[[[
Node >> ratio
   ^ mainCoordinate / maximizeViewRatio
]]]

A subclass can redefine this behavior into:

[[[
NodeWithMargins >> ratio
   ^ super ratio + 10
]]]

How is computed ==defaultNodeSize== evaluating this expression:

[[[
NodeWithMargins new setWindowWithRatioForDisplay
]]]


${slide:title=Another step}$

[[[
Node >> setWindowWithRatioForDisplay
   | defaultNodeSize |
   defaultNodeSize := self ratio.
   self window add: (UINode new with: bandWidth * 55 / defaultWindowSize).
   previousNodeSize := defaultNodeSize.
]]]

How to use a different ==UINode== in subclasses?


${slide:title=Another step: same solution applied}$

We can also extract the ==UINode== instantiation into a separate method.

[[[
Node >> setWindowWithRatioForDisplay
   | defaultNodeSize |
   defaultNodeSize := self ratio.
   self window add: self createUINode.
   previousNodeSize := defaultNodeSize.
]]]

[[[
Node >> createUINode
   ^ UINode new with: bandWidth * 55 / defaultWindowSize
]]]

${slide:title=Improvement: do not hardcode class use}$

Refactor this:

[[[
Node >> createUINode
   ^ UINode new with: bandWidth * 55 / defaultWindowSize
]]]

into:

[[[
Node >> createUINode
   ^ self uiNodeClass new with: bandWidth * 55 / defaultWindowSize.
]]]

[[[
Node >> uiNodeClass
   ^ UINode
]]]

It is a good practice to define methods that return classes.
BTW, this is easy in Pharo because classes are regular objects!


${slide:title=Many take-away messages}$

Small methods are a sign of good design, because:
- they give a name to expressions
- they are a potential ""hook"" for extensibility in subclasses (redefinition)
- they encapsulate complexitiy (no need to read all method definitions) if their name is meaningful

${slide:title=Gruyere-oriented programming}$

+.>file://figures/gruyereWithSlogan|width=65+

${slide:title=Conclusion}$

- Code can be reused and refined in subclasses
- Sending a message in a class defines a ""hook"":
-- i.e., a place where subclasses can ""inject variations""

- Prefer small methods because:
-- it gives names to expressions
-- each one is an extensibility point for subclasses

