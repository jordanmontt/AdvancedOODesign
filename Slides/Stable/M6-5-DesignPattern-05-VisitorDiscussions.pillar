{
	"title":"Some discussions on Visitor",
	"slidesid":"M6S5"
}

${slide:title=Goals}$

More on Visitor:
- Variations on navigation control
- Visitor detractors
- Visit methods granularity
- About double dispatch shortcutting
- ...

${slide:title=Controlling the traversal}$

A visitor embeds a structure traversal that can be implemented:
- in the visitors
- in the domain elements themselves

Usually the visitor controls the traversal but maybe the domain elements are more important

${slide:title=Visitor in control}$

+.>file://figures/Visitor-ExpressionsVisitorInControl2.pdf|width=100+


${slide:title=Items in control}$

+.>file://figures/Visitor-ExpressionsVisitorNotInControl2.pdf|width=100+


${slide:title=Visitor detractors}$

''Visitor is not object-oriented because it externalizes behavior out of objects.''

- Yes, operations applied on objects are defined outside the objects
- Are you ready to lose:
-- ""clear separation"" between operations related state and domain object state?
-- the possibility to ""package multiple"" behaviors ""separately""?
-- the ""incremental definition"" of new operations?


${slide:title=Visitor vs. class extension}$

- Pharo supports class extension
-- i.e., defining methods on a class in another package than the class package

Should we use class extension instead of a Visitor?
- No, using a Visitor is better because:
-- Each Visitor ""encapsulates a complex operation""
-- Each Visitor has its ""own"" state

${slide:title=VisitMethods encode a context}$

- The granularity of visit methods has an impact on the hooks they offer
- ""visit*"" methods can be used to provide context

%${slide:title=Example: visitTemporariesNode: vs. visitNode:}$

%Compare
%[[[
%RBProgramNodeVisitor >> visitSequenceNode: aSequenceNode
%	aSequenceNode temporaries do: [:each | self visitNode: each ].
%	aSequenceNode statements do: [ :each | self visitNode: each ]
%]]]

%vs.

%[[[
%RBProgramNodeVisitor >> visitSequenceNode: aSequenceNode
%	self visitTemporaryNodes: aSequenceNode temporaries.
%	aSequenceNode statements do: [ :each | self visitNode: each ]
%
%RBProgramNodeVisitor >> visitTemporaryNodes: aNodeCollection
%	^ aNodeCollection	do: [ :each | self visitTempDefinitionNode: each ]
%
%RBProgramNodeVisitor >> visitTempDefinitionNode: aNode
%	^ aNode acceptVisitor: self
%]]]


${slide:title=Example: visitTemporariesNode: vs. visitNode:}$

Compare
[[[
RBProgramNodeVisitor >> visitSequenceNode: aSequenceNode
	aSequenceNode temporaries do: [:each | self visitNode: each ].
	aSequenceNode statements do: [ :each | self visitNode: each ]
]]]

vs.

[[[
RBProgramNodeVisitor >> visitSequenceNode: aSequenceNode
	self visitTemporaryNodes: aSequenceNode temporaries.
	aSequenceNode statements do: [ :each | self visitNode: each ]
]]]

- ==visitTemporaryNodes:== encodes the fact that it is only invoked on temporaries
- No need to guess by looking at parent or other information
- But there is a loss...

${slide:title=Short cutting double dispatch}$

Compare:
[[[
RBProgramNodeVisitor >> visitSequenceNode: aSequenceNode
	self visitTemporaryNodes: aSequenceNode temporaries.
	aSequenceNode statements do: [ :each | self visitNode: each ]
]]]

vs.

[[[
RBProgramNodeVisitor >> visitSequenceNode: aSequenceNode
	self visitTemporaryNodes: aSequenceNode temporaries.
	aSequenceNode statements do: [ :each | self visitVariable: each ]

RBProgramNodeVisitor >> visitVariable: aNode
	^ aNode
]]]

${slide:title=Limits}$

[[[
RBProgramNodeVisitor >> visitSequenceNode: aSequenceNode
	self visitTemporaryNodes: aSequenceNode temporaries.
	aSequenceNode statements do: [ :each | self visitVariable: each ]
]]]


The use of ==visitVariable: aNode==
- Short cuts the double dispatch
- Lose the possibility of letting ""any object participates"" by telling the visitor how to handle it



${slide:title=Building generic Visitors can be difficult}$

- Should ==visit== methods return always a result?
- Should ==visit== methods collect the values on collection?

There is no definitive solution
- Often the solution is to have an abstract visitor and to redefine most of the logic per families of tasks



${slide:title=Should we promote collections as domain nodes?}$

- When we iterate on a collection (e.g., of nodes), the collection is not part of the composite domain
- Should we turn such a collection into a domain element?
- Not necessarily, it depends
-- can you change the domain?
-- think in terms of the benefit e.g., having the possibility to define ==visitArrayOf...==

${slide:title=Visit methods and static types}$

Two alternatives to implement visit methods in statically-typed languages:
- Using overloading
-- e.g., ==visit(Number)==, ==visit(Plus)==, ==visit(Times)==
- Using different methods
-- e.g., ==visitNumber(Number)==, ==visitPlus(Plus)==, ==visitTimes(Times)==

""Avoid using overloading"" because:
- you will have to explicitly cast your objects everywhere
- you might have the wrong method executed (overload vs override)


${slide:title=Conclusion}$

- Visitor can be tricky to master
-- use ==accept==/==visit== vocabulary which helps readability
- Visitor is powerful for complex structure operations
-- it provides a ""pluggable recursive treatment"" of a composite structure

