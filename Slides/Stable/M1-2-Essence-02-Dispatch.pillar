{
	"title":"Essence of Dispatch",
	"slidesid":"M1-2"
}

${slide:title=Remember: Implementing not in two methods}$

+Not implementation>file://figures/BooleanHiearchyAndInstancesWithNotMethodsLookup.png|width=80+


${slide:title=Ok so what?}$

- You will probably never implement ==Booleans== in the future
- So, is it ""really"" useful?
- What are the lessons to learn?
- What are the properties of the solution?


${slide:title=Imagine having more than two classes}$

${columns}$

${column:width=45}$
[[[
MicAbstractBlock
		MicAbstractAnnotatedBlock
			    MicAnnotatedBlock
		MicContinuousMarkedBlock
			    MicCommentBlock
			    MicQuoteBlock
			    MicTableBlock
		MicIntermediateBlock
		MicListBlock
			    MicOrderedListBlock
			    MicUnorderedListBlock
		MicListItemBlock
		MicParagraphBlock
			    MacParagraphBlock
			    MacRawParagraphBlock
		MicRootBlock
		MicSectionBlock


]]]

${column:width=55}$

[[[
	    MicSingleLineBlock
	        	MicAnchorBlock
	        	MicHeaderBlock
	        	MicHorizontalLineBlock
	    MicStartStopMarkupBlock
	    	    MicEnvironmentBlock
	    	    ...
	    	    MicMetaDataBlock
	    	    MicSameStartStopMarkupBlock
	    	    	    MicCodeBlock
	    	    	    MicMathBlock
	    	    	    	    MicMathBlockExtensionForTest
	    	    	    	    MicMultilineComment
]]]

Imagine just a method that have one condition for each of such cases!

${endColumns}$

${slide:title=A message send is an open conditional}$

Sending a message:
- selects the ""right"" method to execute based on the class of the receiver
- can be seen as a condition ""without explicit ifs""
- is a dynamic choice

${slide:title=Select the right method}$

${columns}$

${column:width=40}$

[[[
aCollection := {a.bb.c}.
...
aCollection do: [ :e |
    e operation]
]]]

${column:width=50}$

+>file://figures/Design-FatVsDispatchNoFat2.pdf|width=95+

${endColumns}$

${slide:title=But dynamically: new objects can be chosen}$

${columns}$

${column:width=40}$

[[[
aCollection := {a.bb.c.aa}.
...
aCollection do: [ :e |
    e operation]
]]]

${column:width=50}$

+>file://figures/Design-FatVsDispatchNoFatDyn.pdf|width=95+

${endColumns}$


${slide:title=Sending a message is making a choice}$

- Message send is a ""choice"" operator
- Each time you send a message, the execution ""selects the right"" method depending on the class of the receiver
- So, ""How do we express choices""?

${slide:title=How do we express choices?}$

Could we have the same solution with a ""single"" ==Boolean== class?

+>file://figures/Design-FatVsDispatchBoolean.pdf|width=75+

${slide:title=Classes play case roles}$

- To activate the choice operator we must have ""choices""
- A ""class"" represents a choice (a case)


${slide:title=One class vs. a hierarchy}$

+>file://figures/Design-FatVsDispatch.pdf|width=75+

${slide:title=Class hierarchy supports for dynamic dispatch}$

- More modular
- No need to introduce complex conditions
- A hierarchy provides a way to specialize behavior
- No need to recompile existing methods
- You only focus on one class at a time

+>file://figures/Design-FatVsDispatch.pdf|width=40+


${slide:title=Message dispatch supports modularity}$

+>file://figures/Design-FatVsDispatchWithPackages.pdf|width=65+

We can package different classes into different packages (better modularity)

${slide:title=Limit impact of changes}$

+>file://figures/Design-FatVsDispatchWithPackages2.pdf|width=65+

If a client receives instances of ==E== (in addition to classes of first package), the client code does not have to change


${slide:title=Message Send is powerful}$

- Message sends are supporting ""choices""
- The execution engine acts as a conditional switch: Use it!
- Classes act as "case statements"
- But with messages, the case statement is ""extensible"" by adding new classes without breaking client code

${slide:title=Let the receiver decide}$

- Sending a message lets the receiver decide
- Client does not have to decide
- Client code is more declarative: give orders
- Different receivers may be substituted dynamically

${slide:title=Summary: Cornerstone of OOP}$

- Avoid conditionals (cf. AntiIfCampaign)
- Use objects and messages whenever you can
- Let the receiver decide (Do not ask, tell)
- Message sends act as potential dynamic conditionals
- Class hierarchy supports for dynamic dispatch

