{
	"title":"Behavior delegation at work",
	"subtitle":"The case of the class printer",
	"author":"S. Ducasse",
	"slidesid":"2022"
	
}


${slide:title=Goal}$

- Think modular
- Looking at the class definition printer
- Check design approach in Pharo


${slide:title=Context: Class Definition}$

- How to support various formats
- in a modular way


${slide:title=Challenges}$

How to support:
-- Old Squeak syntax, Pharo previous and Fluid new one
-- orthogonally to  class, metaclass, trait...
- How to control the complexity?
-- Slots should not be displayed in Old Pharo
- How to avoid checks everywhere?
- And removal one definition any time without recompilation


${slide:title=First hacked version in Pharo 70/80}$

[[[
ClassDescription >> definition
	(self needsSlotClassDefinition or: [ Slot showSlotClassDefinition ]) 
		ifTrue: [ ^ self definitionWithSlots ].
	^ self definitionWithoutSlots
]]]

[[[
Metaclass >> definition
	(self slotsNeedFullDefinition or: [ Slot showSlotClassDefinition ]) 
		ifTrue: [ ^ self definitionWithSlots ].
	^ self definitionWithoutSlots
]]]

Smell like duplication

${slide:title=Hacked in tools too}$

[[[
ClyClassCreationToolMorph >> classTemplate

	| template |
	template := Slot showSlotClassDefinition
		ifTrue: [ 
			'Object subclass: #NameOfSubclass
	slots: {}
	classVariables: {}
	package: ''' ]
		ifFalse: [ 
			'Object subclass: #NameOfSubclass
	instanceVariableNames: ''''
	classVariableNames: ''''
	package: ''' ].
	^ template , self packageName , '''' 
]]]


${slide:title=Thinking... about a solution}$

Think 5 min how you would solve it

${slide:title=Solution: Delegating to a class definition printer}$

- Create class definition printers
- A kind of Strategy
- A hierarchy of printers + a factory + some double dispatch

[[[
ClassDefinitionPrinter ( forClass )
	FluidClassDefinitionPrinter
	LegacyClassDefinitionPrinter
	OldPharoClassDefinitionPrinter
]]]


${slide:title=Solution: Delegating to a class definition printer}$

+>file://figures/ClassPrinter.pdf|width=80+


${slide:title=The class asks a printer}$

[[[
ClassDescription >> definitionString
	"Return the string of the class definition, each of my subclass may tell the printer how to printer it. 
	A kind of double dispatch since we have multiple printers and multiple entities to be printed."

	^ self definitionPrinter definitionString
]]]
[[[	
ClassDescription >> definitionPrinter
	"Return a configurated printer associated with the current class definition format."

	^ ClassDefinitionPrinter for: self
]]]


${slide:title=A printer}$

Knows how to print
- class (==classDefinitionString==)
- metaclass (==metaclassDefinitionString==)
- trait

${slide:title=Fluid printer: a class}$

[[[
FluidClassDefinitionPrinter >> classDefinitionString

	^ String streamContents: [ :s | 
		  forClass superclass
			  ifNotNil: [ s nextPutAll: forClass superclass name ]
			  ifNil: [ s nextPutAll: 'nil' ].
		self msgAndClassNameOn: s.
		forClass classLayout isFixedLayout 
				ifFalse: [ self layoutOn: s ].
		...
		forClass slots ifNotEmpty: [ self slotsOn: s ].
		forClass classVariables ifNotEmpty: [ self sharedVariablesOn: s ].
		forClass sharedPools ifNotEmpty: [ self sharedPoolsOn: s ].
		self tagOn: s.
		self packageOn: s ]
]]]

${slide:title=Fluid printer: a metaclass}$

[[[
FluidClassDefinitionPrinter >> metaclassDefinitionString 

	^ String streamContents: [ :strm |
		forClass superclass 
			ifNotNil: [ forClass = ProtoObject class
							ifFalse: [ 
								strm 
									nextPutAll: forClass superclass name;
									nextPutAll: ' << ';
									nextPutAll: forClass name ]
							ifTrue: [ strm 
									nextPutAll: 'Class class << ';
									nextPutAll: forClass name ] ]
			ifNil: [ strm nextPutAll: 'ProtoObject ' ].
		self lastTraitsOn: strm.
		forClass slots ifNotEmpty: [ self lastSlotsOn: strm ] ]
]]]

${slide:title=Old Pharo printer: class}$

[[[
OldPharoClassDefinitionPrinter >> classDefinitionString
	^ forClass needsSlotClassDefinition 
		ifTrue: [ (ClassDefinitionPrinter fluid for: forClass) classDefinitionString ]
		ifFalse: [ self basicClassDefinitionString ]
]]]

[[[
basicClassDefinitionString

	| stream |
	stream := (String new: 800) writeStream.
	forClass superclass
		ifNotNil: [ stream nextPutAll: forClass superclass name ]
		ifNil: [ stream nextPutAll: 'ProtoObject' ].
	stream
		nextPutAll: forClass kindOfSubclass;
		store: forClass name.
	self traitCompositionOn: stream.
	self instanceVariablesOn: stream.
	self classVariablesOn: stream.
	self poolOn: stream.
	self packageOn: stream.
	forClass superclass ifNil: [ 
		stream
			nextPutAll: '.';
			cr.
		stream nextPutAll: forClass name.
		stream
			space;
			nextPutAll: 'superclass: nil' ].
	^ stream contents
]]]



${slide:title=Tool logic}$

[[[
ClassCreationToolMorph >> classTemplate

	^ ClassDefinitionPrinter new 
			compactClassDefinitionTemplateInPackage: self packageName
]]]

${slide:title=Analysis}$

- Modular: One format = one printer
- One printer supports multiple related features (expansion, template, class printing)
- Support reuse within the hierarchy
- Defaulting within printers
-- if necessary legacy printer redirects to fluid printer


${slide:title=More}$

How to support printing different objects on different printers
- Traits, Classes, and Metaclasses
- Legacy, OldPharo, and Fluid


${slide:title=Double Dispatch}$

[[[
ClassDefinitionPrinter >> definitionString
	"The method is part of the double dispatch. It is an extra starting point. 
	Each entity will select the right definition and call me back.
	Normally this method is not used because the main point is the class...."
	
	^ forClass definitionStringFor: self
]]]

[[[
Class >> definitionStringFor: aConfiguredPrinter
	^ aConfiguredPrinter classDefinitionString

Trait >> definitionStringFor: aConfiguredPrinter
	^ aConfiguredPrinter traitDefinitionString

TraitedMetaclass >> definitionStringFor: aConfiguredPrinter
	^ aConfiguredPrinter traitedMetaclassDefinitionString 
]]]


${slide:title=Encapsulate printer selection}$

- Limit reference to specific printers
- Only reference the superclass

[[[
Object << #ClassDefinitionPrinter
		slots: { #forClass };
		sharedVariables: { #DisplayEmptySlots . #ShowFluidClassDefinition };
		tag: 'ClassDefinitionPrinter';
		package: 'Kernel'
]]]


[[[
ClassDefinitionPrinter >> new
	^ self showFluidClassDefinition
			ifTrue: [ self fluid ]
			ifFalse: [ self oldPharo ]
]]]


${slide:title=Possibility to refer to legacy definition}$

[[[
ClassDescription >> oldDefinition

	^ ClassDefinitionPrinter legacy
		for: self;
		definitionString
]]]


${slide:title=Conclusion}$

- Dispatch over objects
- Avoid complex conditional cases
- Concentrate object creation point

