{
    "title":"About state Design Pattern",
    "slidesid":"M5-2"
}


${slide:title=Goals}$

- Motivating Example
- Representing Different States as Objects
- Operations and State Transitions are Encapsulated by each state
- Handling Instance State

${slide:title=Analysing a case}$

- Imagine an automatic coffee machine.
- It has different states:
-- Waiting for Order
-- Waiting for Payment
-- Making Coffee
-- Coffee Ready

${slide:title=Our States}$

+>file://figures/DPState-StateDiagram.pdf|width=85+

${slide:title=Our Operations}$

[[[
CoffeeMachine >> acceptOrder: anOrder
CoffeeMachine >> howMuchIsIt
CoffeeMachine >> pay: someMoney
CoffeeMachine >> coffeeDone
CoffeeMachine >> takeCoffee
]]]


${slide:title=Our Operations}$

- The available operations depend on the current state
- We need to add a lot of conditional code
[[[
CoffeeMachine >> acceptOrder: anOrder
	"Checking state every time..."
	machineState = #idle ifFalse: [ self error: 'Machine working...'].
	"Changing state in each operation"
	machineState := #toPay.
	"... Do the magic to order a coffee..."
]]]

${slide:title=Repeated Pattern}$

[[[
CoffeeMachine >> howMuchIsIt
	"Checking state every time..."
	machineState = #toPay ifFalse: [ self error: 'Invalid State'].

	"Some operations do not change state"
	
	^ ourPrice
]]]

${slide:title=Proposed Idea}$

- Represent each state as an object
- We delegate the operations to the state

+>file://figures/DPState-ClassDiagram.pdf|width=85+


${slide:title=Our new Operations (1/2)}$

[[[
CoffeeMachine >> acceptOrder: anOrder
	^ machineState acceptOrder: anOrder onMachine: self
]]]

[[[
MachineState >> acceptOrder: anOrder onMachine: aMachine
	^ self error: 'Invalid State'
]]]

[[[
IdleState >> acceptOrder: anOrder onMachine: aMachine
	"The operation code"
	aMachine doTheMagicToOrder: anOrder
	"To the new State"
	aMachine machineState: ToPayState new.
]]]

${slide:title=Our new Operations (2/2)}$

[[[
CoffeeMachine >> howMuchIsIt
	^ machineState howMuchIsIt: self
]]]

[[[
MachineState >> howMuchIsIt: aMachine
	^ self error: 'Invalid State'
]]]

[[[
IdleState >> howMuchIsIt: aMachine
	^ aMachine ourPrice
]]]


${slide:title=Advantanges}$

- Each state just implements their operations
- State transitions are implemented in each state
- Less conditional code
- Elegant solution when having many states

${slide:title=Where to Put the instance state? (1/3)}$

- Instance State as:
-- Selected coffee
-- Price

- We can put the machine instance state in:
-- The Machine Object
-- In the State object

${slide:title=Where to Put the instance state? (2/3)}$

- In the Machine Object:
-- Useful if the internal state is the same for all the machine state
-- We don't need to copy on each state change
-- Bad if each state has different instance variables

${slide:title=Where to Put the instance state? (3/3)}$

- In the State Object:
-- Useful if the internal state is different for all the machine state
-- Each state object has direct access to the instance state, we don't need accessors
-- Creating a state requires passing all instance variables that it stores

${slide:title=Conclusion}$

- Useful having an object with many states
- Encapsulates the operations and the state transitions
- Use delegation instead of conditional code
- Easy to add new states and operations
- It is a more complex solution, we need to trade off the new complexity vs clarity/flexibility



