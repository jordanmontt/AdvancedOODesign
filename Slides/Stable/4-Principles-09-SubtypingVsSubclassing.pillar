{
	"title":"Subclassing vs. Subtyping",
	"author":"S. Ducasse"
}


${slide:title=Goals}$

- Discuss relation between the ""API"" of a class and its ""subclasses""?
- Discuss relation between the ""API"" of a class and its ""clients""?
- Compare ""subtyping"" \& ""subclassing""?
- Impact on design
- Subtyping is good even in dynamically-typed languages


${slide:title=Example 1}$

[[[
class Poem extends LinkedList
{  
	...
}
]]]

What do you think about it?
- Yes we can write this code
- What do you think of? Does it make sense?
A poem API 
- is ==addWord(word)==, ==isAlexandrin()==, ==isHaiku()==, ...
- should not contain ==addBeforeLink(aLinkOrObject, otherLink)== (that is part of ==LinkedList==)


${slide:title=Another example}$

[[[
class Stack extends LinkedList  
{
	...
}
]]]

What do you think about it?
- Yes we can write this code. 
- What do you think of? Does it make sense?
A ==Stack== API 
- is ==pop()==,==push(el)==, ==top()==, ==isEmpty()== 
- should not contain ==LinkedList== methods.

${slide:title=Subclassing}$

The two previous examples are examples of subclassing, e.g., a subclass does not have an API in relation 
with its superclass.

It reuses the superclass code.

${slide:title=Subtyping/subclassing and type systems}$

Did you notice previous code snippets were in java tiny syntax... because:
- You ""can"" use subtyping and subclassing in ""dynamically-typed"" languages
- You ""can"" use subtyping and subclassing in ""statically-typed"" languages

The compiler's type checker does not check such a point 
- It just checks that we can put ""squares"" into ""squares""


${slide:title=Let us study a simple example}$

Basic ==Stack==:

[[[
>>> s push: 12.
>>> s push: 24.
>>> s top
>>> s pop
24
>>> s isEmpty
false
]]]



${slide:title=Stack as subclass of OrderedCollection}$

[[[
OrderedCollection << Stack
]]]

[[[
Stack >> pop
	^ self removeFirst

Stack >> push: anObject
	self addFirst: anObject

Stack >> top
	^ self first
]]]

We get ==size==, ==includes:==, ==do:==, ==collect:== for free. 


${slide:title=Wait!}$

- What do we do with the ""rest"" of the ==OrderedCollection== API?
- Our stack also understands: ==add:beforeIndex:==, ==addAllFirstUnlessAlreadyPresent:==, ==join:==...
- a Stack ""is not"" an ==OrderedCollection==!
- In a client program we cannot replace an ==OrderedCollection== by a ==Stack==

${slide:title=Wait!}$

Some messages that make sense on the class ==OrderedCollection== do not make sense on the class ==Stack==
[[[
OrderedCollection new add: newObject beforeIndex: index 
]]]

[[[
OrderedCollection new add: newObject ; removeFirst
]]]

${slide:title=We could cancel some operations}$

[[[
Stack >> removeFirst
	self error
]]]

${slide:title=And get a convoluted pop?}$

Remember:
[[[
Stack >> pop
	^ self removeFirst
]]]

Jumping over cancelled operation :(
[[[
Stack >> pop
	^ super removeFirst
]]]
- Ugly 
- Complexify the solution 
- Complexify the evolution



${slide:title=Stepping back}$

- There is not a ""simple relationship"" between ==Stack== and ==OrderedCollection== APIs.
- ==Stack== interface is not an ""extension"" nor a ""subset"" of ==OrderedCollection== interface.

${slide:title=Imagine CountingStack}$


[[[
CountingStack >> pop
	operations := operations + 1.
	^ super pop
]]]

[[[
CountingStack >> push: anElement
	operations := operations + 1.
	^ super push: anElement
]]]

${slide:title=Compare the two uses}$

+.>file://figures/SubtypingSubclassing.pdf|width=100+

${slide:title=Compare the two replacements}$

+.>file://figures/SubtypingSubclassing2.pdf|width=100+



${slide:title=Back to Stack}$

Better use composition! A stack holds a collection of elements

[[[
Object << Stack
	slots: {#elements}
]]]

[[[
Stack >> push: anElement 
	elements addFirst: anElement
]]]

[[[
Stack >> pop
	^ element ifNotEmpty: [ element removeFirst ]
]]]




${slide:title=Subclassing inheritance}$

- Inheritance for code reuse
- Subclass reuses code from superclass, but as a ""different"" specification
- It cannot be used everywhere its superclass is used. Usually overrides of code

""Cons:""
- ""Lowers"" understanding
- ""Hampers"" future evolution
- ""Forces"" strange code

${slide:title=Subtyping inheritance}$

- ""Reuse"" of specifications: interface inheritance
- A subclass ""refines"" superclass specifications
- A program that works with Numbers should 'work' with Fractions
- A program that works with Collections should 'work' with Arrays


${slide:title=Subclasses must not cancel methods}$

[[[
Stack >> removeFirst
	self error
]]]

This is a sign for bad design decision
- Cheap 
- But you will pay later


${slide:title=RestrictedStack}$

Imagine that we have a stack where we can only push elements smaller than the top elements

[[[
push: anElement
	self top < anElement 
		ifTrue: [^ self ]
	super push: anElement
]]]

What is the good superclass?
- ==Stack== Probably.
- It would be better if the client program behavior but not mandatory or possible.
- A subclass does not have to make sure that client program works (this is behavioral subtyping)


${slide:title= Inheritance and polymorphism}$

- Polymorphism works best with ""conforming/substituable"" interfaces
- Subtyping inheritance creates ""families"" of classes with ""similar interfaces""
-- An abstract class describes an interface fulfilled by its subclasses
- Subtyping inheritance helps software reuse by creating ""polymorphic objects""
- Now classes in different hierarchies implementing the same interface can also ""be substituable""

${slide:title='extend' one term for two concepts}$

- We only have one ==extend== or ==subclass:== construct in programming language
- Still you can express a ""subtype"" or ""subclass"" relationship between a class and its subclass.
- Subclassing/subtyping is not related to static typing


${slide:title=Conclusion}$

- Subtyping is about  program specification ""reuse""
- Subtyping is about to create ""family of classes sharing common API""
- ""Avoid"" subclassing: it is a bad idea




