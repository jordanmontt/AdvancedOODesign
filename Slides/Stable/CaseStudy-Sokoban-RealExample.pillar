{
    "title":"Learning From Real Examples",
    "subtitle":"Learning from a Sokoban implementation",
    "slidesid":"",
    "author":""
}

${slide:title=Goal}$

- Think about model
- Think about messages and condition

${slide:title=Studying a Sokoban Implementation}$

Sokoban is a puzzle video game genre in which the player pushes crates or boxes around in a warehouse, trying to get them to storage locations.
*https://en.wikipedia.org/wiki/Sokoban*

+.>file://figures/SokobanOld.png|width=30+

${slide:title=Studying a Sokoban Implementation}$

- Developed by some students of I. Franko University (Lviv)
- Thank you so much!

+.>file://figures/LearnFEx-Sokoban1.png|width=65+


${slide:title=Looking the implemented core model}$

- Block
-- EmptyBlock
-- Wall
- GameModel
- GameState
- Maze
- MazeTemplate
- MoveResult
-- Move
--- Push
-- NoMove





${slide:title=What is your model for the game?}$

${columns}$

${column:width=60}$

- Apply ""Speculate about Design"" object-oriented reengineering pattern

- ""Intent:"" Progressively refine a design against source code by checking hypotheses about the design against the source code. 

- Use your development expertise to conceive a hypothetical class diagram representing the design.

${column:width=40}$

+.>file://figures/OORP.jpg|width=30+

${endColumns}$



${slide:title=Take some minutes to sketch a list of classes}$

+.>file://figures/LearnFEx-Sokoban1.png|width=65+



${slide:title=Our version a possible implementation}$

${columns}$

${column:width=60}$

- Wall
- Floor
- Box
- Robot
- Target
- Board

And 
- Template/Level
- Moves

${column:width=40}$

+.>file://figures/LearnFEx-Sokoban1.png|width=120+

${endColumns}$

${slide:title=Gut feeling analysis}$

- The Block implemented model looks to shallow
- Remember the lectures of implementing "not, or..."
- Classes are representing case
- Classes are basis for dispatch
- Not enough classes leads to tricky conditionals and monolithic systems

+.>file://figures/Design-FatVsDispatch.pdf|width=50+

${slide:title=Let us check the API}$

- isEmptyBlock
- isWall

Let us check the way this API is used

${slide:title=Too many ifs....}$

[[[
GameView >> drawBlock: aBlock on: aCanvas
	aBlock isWall ifTrue: [ self drawWall: aCanvas ].
	aBlock isEmptyBlock ifTrue: [ 
		aBlock hasPlayer ifTrue: [ 
			aBlock hasTarget ifTrue: [ self drawTargetAndPlayer: aCanvas ].
			aBlock hasTarget ifFalse: [ self drawPlayer: aCanvas ]].
		aBlock hasPlayer ifFalse: [ 
			aBlock hasBox ifTrue: [ 
				aBlock hasTarget ifTrue: [ self drawTargetAndBox: aCanvas ].
				aBlock hasTarget ifFalse: [ self drawBox: aCanvas ] ].
			aBlock hasBox ifFalse: [ 
					aBlock hasTarget ifTrue: [ self drawTarget: aCanvas ].
					aBlock hasTarget ifFalse: [ self drawEmptyBlock: aCanvas ] ].
	]
]]]

${slide:title=Analysis}$

The model only defines
- EmptyBlock and 
- Wall

No Player, no target, no box.

Too much logic is put in EmptyBlock

Too much Ask not enough Tell (Do not Ask, Tell)

${slide:title=A better model}$	

- Block
-- Box
-- BoxOnTarget
-- EmptyBlock
-- Player
-- PlayerOnTarget (no need if we can have overlapping cells)
-- Wall


${slide:title=A nicer solution}$	


[[[
GameView >> drawBlock: aBlock on: aCanvas
	aBlock isWall ifTrue: [ self drawWall: aCanvas ].
	aBlock isEmptyBlock ifTrue: [ 
	...
]]]

Becomes

[[[
GameView >> drawBlock: aBlock on: aCanvas
	aBlock drawOn: aCanvas view: self

Wall >> drawOn: aCanvas view: aView
	aView drawWall: aCanvas

EmptyBlock >> drawOn: aCanvas view: aView
	aView drawEmptyBlock: aCanvas
]]]

- We tell a block to draw itself and it tells how to the canvas
- Double dispatch to the rescue

${slide:title=Back to the model}$

What are:
- MoveResult
-- Move
--- Push
-- NoMove

Kind of Command objects
Good to support Undo

${slide:title=Let us study the API}$


[[[
MoveResult >> isMove
	^ false
MoveResult >> isPush
	^ false
MoveResult >> isNoMove
...
]]]

Again testing kind methods

Testing kind methods are the same as ==x class = MoveResult==

${slide:title=Check how they are used}$

[[[
GameState >> moveBy: aDirection
	| moveResult |
	moveResult := maze moveBy: aDirection.
	moveResult isMove ifTrue: [ moves := moves + 1 ].
	moveResult isPush ifTrue: [ 
		pushes := pushes + 1.
		moves := moves + 1 ].
	self addMoveResult: moveResult.
]]]

${slide:title=Do not ask tell}$

[[[
GameState >> moveBy: aDirection
	| moveResult |
	moveResult := maze moveBy: aDirection.
	moveResult updateGameState: self.	
	self addMoveResult: moveResult.

Move >> updateGameState: aGameState
	aGameState incrementMoves

Push >> updateGameState: aGameState
	super updateGameState: aGameState.
	aGameState increasePushes

NoMove >> updateGameState: aGameState 
	self 
]]]

${slide:title=Conclusion}$

- Challenge kind testing methods
- Check their use
- Messages act as a dispatcher
- Avoid conditional when possible


