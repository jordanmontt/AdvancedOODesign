{
    "title":"Blocks vs. Objects",
    "subtitle":"",
    "author":"StÃ©phane Ducasse"
}

${slide:title=Goal}$

- Thinking about API
- Rethinking block usage
- Blocks are powerful and handy
- Small objects are better in the long run


${slide:title=Blocks are powerful}$

Blocks support
- Iterators
- New iterator definition
- DSL like APIs


${slide:title=Central to message based syntax}$

- Remember blocks freeze execution and give power to decide when to execute
- Block execution controlling behavior are key for Pharo compact syntax

[[[
False >> ifTrue: trueAlternativeBlock ifFalse: falseAlternativeBlock 
	"Answer the value of falseAlternativeBlock. Execution does not
	actually reach here because the expression is compiled in-line."
	^ falseAlternativeBlock value
]]]


[[[
True >> ifTrue: trueAlternativeBlock ifFalse: falseAlternativeBlock 
	"Answer with the value of trueAlternativeBlock. Execution does not 
	actually reach here because the expression is compiled in-line."

	^ trueAlternativeBlock value
]]]

${slide:title=Iterators}$

Blocks are the cornerstone of iterators
[[[
#(1 2) allSatisfy: [ :each | each even ]
]]]


[[[
(String streamContents: [:s | #(1 2 3) 
	do: [:each | s << each asString] 
	separatedBy: [s << ', ']])
]]]


${slide:title=New iterator definition}$

Blocks support definition of ""new"" iterators

[[[
SequenceableCollection >> pairsDo: aBlock
	"Evaluate aBlock with my elements taken two at a time.  If there's an odd number of items, ignore the last one.  
	Allows use of a flattened array for things that naturally group into pairs.  See also pairsCollect:"

	1 
		to: self size // 2 
		do: [ :index | aBlock 
							value: (self at: 2 * index - 1) 
							value: (self at: 2 * index) ]
]]]

${slide:title=DSL like APIs}$

[[[
GLMCompositePresentation new tabulator with: [ :t |
	t transmit from: #index; to: #details; andShow: [ :composite |
		composite text
			title: 'XML';
			display: [ :file | file contents ].
		composite list 
			title: 'Targets';
			display: [ :file | (XMLDOMParser parse: file contents) // 'target' ];
			format: [ :xmlElement | xmlElement attributeAt: 'name' ].
		composite roassal2
			title: 'Dependencies';
			initializeView: [ RTMondrian new ];
			painting: [ :view :file | 
				...
				] ].
]]]

${slide:title=Blocks are on the spot poor literal objects}$

- What is the difference between a block and a simple object understanding ==value==?
- With a block, no need to create a class, no need to define a method
But...

${slide:title=Analysis}$

Blocks are nice but not a panacea:
- Storing and changing state is cumbersome
- One single message!
- They do not expose well the arguments they need
- It makes scripting easy but extension difficult
- Having richer API is impossible


Let us study the limits!

${slide:title=Blocks are black boxes}$

- You can only send the messages ==value*== to a block.
- It is hard and cumbersome to store and access state in a block as in an object
-- imagine passing a block around and want to accumulate information

${slide:title=Arguments?}$

- What if you want optional arguments?
-- then you are doomed to chose which arguments and which order
- If you use ==cull:==, it means that you bent the rules


${slide:title=Argument order requires to know the block definition!}$

- Blocks do not expose well the arguments they need

[[[
aCol inject: default into: [:a :b | ... ]
]]]

What is ==a== and ==b==?


${slide:title=Block Limits}$

- Saving blocks is a painful
- Adding behavior (i.e., offering another message) is impossible
- Extension via superclass / hook of block behavior is impossible


${slide:title=Long Blocks are Missed Reuse Opportunity}$

- Impossible to turn into a template and modify 
-- Remember sending a message is a plan for reuse
- Long blocks are a plague

${slide:title=Long Blocks are Missed Reuse Opportunity}$

${columns}$

${column:width=50}$

Instead of 
[[[

...	display: [:v | 
		| tmp | 
		tmp := v size + 100. 
		v 
			foo;
			bar; 
			more ]
]]]

${column:width=50}$

Prefer

[[[

method: v 
	| tmp | 
	tmp := v size + 100. 
	v	
		foo;
		bar; 
		more

...	display: [:v | xxx method: v ]
]]]

${endColumns}$

This way you can override ==methods:== in subclasses.


${slide:title=Conclusion}$

- When you use blocks, keep them as small as possible
- Use them to script DSLs but NOT to define your domain model
- Create classes and pass their instances around.


