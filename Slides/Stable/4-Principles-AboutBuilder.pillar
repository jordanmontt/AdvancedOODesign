{
	"title":"Builder Variations",
	"subtitle":"",
	"author":"S. Ducasse",
	"slidesid":"2022"
}


${slide:title=Goal}$

- Discuss about builder API
- Identify variations


${slide:title=Microdown}$

[[[

# Hello Pharo

Microdown is a cool markdown.
It is used to generate
- slides
- books
- class comments
]]]

${slide:title=Microdown class comment}$

+>figures/SpAbstractTextPresenter.png+

${slide:title=Microdown builder}$

Microdown offers a builder
- To avoid user manipulating strings
- To encapsulate the building logic
- In addition every single class can customize  `buildMicroDownUsing: aBuilder withComment: aString`


${slide:title=Microdown builder}$

On ==SpAbstractWidget==

[[[
buildMicroDownUsing: aBuilder withComment: aString
	
	super buildMicroDownUsing: aBuilder withComment: aString.

	"Example code"
	self addDocumentSectionExampleCode: aBuilder.
	"Factory method"
	self addDocumentSectionFactoryMethod: aBuilder.
	"Sections"
	self documentSections keysAndValuesDo: [ :label :methods |
		self addDocumentSection: aBuilder label: label methods: methods ].
	"Hook for extra sections"
	self addDocumentExtraSections: aBuilder.
	"Hierarchy"
	self addDocumentSectionHierarchy: aBuilder.
	"Transmissions"
	self addDocumentSectionTransmissions: aBuilder.	
]]]	
	

${slide:title=Microdown builder 2}$

[[[	
addDocumentSection: aBuilder label: label methods: methods
	
	methods ifEmpty: [ ^ self ].
	aBuilder newLine.
	aBuilder header: [ :builder | builder text: label ] withLevel: 2.
	aBuilder unorderedListDuring: [  
		(methods sorted: #selector ascending) do: [ :each |
			aBuilder item: [
				aBuilder monospace: (each methodClass name, '>>#', each selector) ] ] ]
]]]


${slide:title=About leave element}$

For leaves, i.e., untrustured text or elements
- Just pass the argument
- Give simple order

[[[
builder text: 'Bold'
]]]

[[[
aBuilder newLine
]]]


${slide:title=About composite elements}$

- For nested elements, we should provide a way to let the user defines the inner part
- We use blocks for this. 

[[[
builder bold: [ builder text: 'This is a text in bold' ]
]]]

[[[
builder bold: [ builder italic: [ builder text: 'This is a text in bold and italic' ]]
]]]

[[[
builder 
	header: [ 
		builder bold: [ builder text: 'Very']. 
		builder text: 'Important' ] 
	withLevel: 2.
]]]

${slide:title=About composite: Cell example}$

[[[
testCell

	self
		assert: (builder
		cell: [ 
			builder text: 'this is '.
			builder bold: [ builder text: 'bold' ] ]) contents
		equals: '| this is **bold** '
]]]


${slide:title=Alternative design}$

[[[
aBuilder header: [ :builder | builder text: 'Factory method' ] withLevel: 2.
]]]

[[[
aBuilder header: [ aBuilder text: 'Factory method' ] withLevel: 2.
]]]


${slide:title=No argument design}$

[[[
aBuilder header: [ aBuilder text: 'Factory method' ] withLevel: 2.
]]]

- Only the builder for all the messages
- More compact


${slide:title=No argument implementation}$

[[[
header: aBloc withLevel: anInteger
	self rawHeader: aBloc withLevel: anInteger.
	self newLine

rawHeader: aBloc withLevel: anInteger
	self raw: (HeaderMarkup repeat: anInteger).
   self raw: String space.
   aBloc value
]]]

${slide:title=Argument Design}$

[[[
aBuilder header: [ :builder | builder text: 'Factory method' ] withLevel: 2.
]]]

- Each API can have its owns  the builder 
- We can have an hierarchy of builder each one representing finer context
- More verbose


${slide:title=Argument implementation}$

[[[
rawHeader: aBloc withLevel: anInteger
	self raw: (HeaderMarkup repeat: anInteger).
	self raw: String space.
	aBloc value: SpecialMicrodownBuilder new
]]]

${slide:title=Analysis}$

- With an explicit argument builder, we can also subclass the builder and modify partially the builder behavior
- We could have specialisation builder that produces table of contents
- It feels like visitor hooks

