{
	"title":"Builder Variations",
	"author":"S. Ducasse"
}


${slide:title=Goal}$

- Discuss about builder API
- Identify and understand variations


${slide:title=Microdown}$

A better markdown :)
- compact (subset of markdown)
- more extensible (superset of markdown)

[[[
# Hello Pharo

Microdown is a cool markdown.
It is used to generate
- slides
- books
- class comments
]]]

Used for:
- class comments
- slides, books, and documentation

${slide:title=Default Microdown class comment}$

+>figures/CommentPoint.png+

${slide:title=Specialized Microdown class comment}$

+>figures/CommentSpAbstractTextPresenter2.png+

${slide:title=Specialized Microdown class comment}$

+>figures/CommentBaseline.png+


${slide:title=How to generate microdown?}$

""To avoid:"" string concatenation
- Expose users to possible syntax changes
- Tool builders do not have to learn syntactic quirks

Better provide a ""scripting API""
- ""Abstract away"" details
- Support ""future changes""

""Hooks/Extensibility""
- Every single class can ""customize"" `buildMicroDownUsing: aBuilder withComment: aString` hook


${slide:title=Microdown class comment hook}$

[[[
renderComment: aString of: aClassOrPackage 
	"Return aString as part of the templated class comment, when rendering is on.
	Else aString."

	| builder |
	builder := Microdown builder.
	aClassOrPackage buildMicroDownUsing: builder withComment: aString.
	^ self render: builder contents
]]]

${slide:title=Default class comments}$

[[[
Class >> buildMicroDownUsing: aBuilder withComment: aString
	
	aBuilder 
		header: [ 
				aBuilder text: 'Class: '.
				aBuilder text: self name ] 
		withLevel: 1;
			horizontalLine;
			text: aString
]]]



${slide:title=Hook for widgets}$

[[[
SpAbstractWidget >> buildMicroDownUsing: aBuilder withComment: aString
	
	super buildMicroDownUsing: aBuilder withComment: aString.
	self addDocumentSectionExampleCode: aBuilder.
	self addDocumentSectionFactoryMethod: aBuilder.
	self documentSections keysAndValuesDo: [ :label :methods |
		self addDocumentSection: aBuilder label: label methods: methods ].
	self addDocumentExtraSections: aBuilder.
	self addDocumentSectionHierarchy: aBuilder.
	self addDocumentSectionTransmissions: aBuilder.	
]]]	
	

${slide:title=Hook for widgets (2)}$

[[[	
BaselineOf>> addDocumentSection: aBuilder label: label methods: methods
	
	methods ifEmpty: [ ^ self ].
	aBuilder newLine.
	aBuilder header: [ :builder | builder text: label ] withLevel: 2.
	aBuilder unorderedListDuring: [  
		(methods sorted: #selector ascending) do: [ :each |
			aBuilder item: [
				aBuilder monospace: (each methodClass name, '>>#', each selector) ] ] ]
]]]


${slide:title=About builder API}$

- All microdown elements and their parametrization
- ==text:==, ==bold:==, ==anchor:==, ==codeblock:==, 
- ==comment:==
- ==item==...


${slide:title=About generation of leave elements}$

For leaves, i.e., unstructured text or elements
- Just pass the argument
- Give simple order

[[[
builder text: 'Bold'
]]]

[[[
aBuilder newLine
]]]


${slide:title=Codeblock is also a leave element}$
[[[
codeblock: aString firstLineAssociations: aCol
	self raw: CodeblockMarkup.
	aCol do: [ :each | self 
						raw: each key;
						raw: '=';
						raw: each value value asString
						"so that we can put format such as bold in the value"]
			separatedBy: [ self raw: '&' ].
	self newLine.
	self raw: aString.
	self newLine.
	self raw: CodeblockMarkup.
	self newLine.
]]]




${slide:title=About generation of composite elements}$

- For nested elements, we should provide a way to let the user defines the ""inner"" part
- Use blocks as a way to support wrapping elements

[[[
builder bold: [ builder text: 'This is a text in bold' ]
]]]

[[[
builder bold: [ builder italic: [ builder text: 'This is a text in bold and italic' ]]
]]]

[[[
builder 
	header: [ 
		builder bold: [ builder text: 'Very']. 
		builder text: 'Important' ] 
	withLevel: 2.
]]]

${slide:title=Composite example: Cell}$

[[[
testCell

	self
		assert: (builder
			cell: [ 
				builder text: 'this is '.
				builder bold: [ builder text: 'bold' ] ]) contents
		equals: '| this is **bold** '
]]]

${slide:title=Composite generation implementation}$

[[[
MicrodownTextualBuilder >> bold: aBlock
	self raw: BoldMarkup.
	aBlock value.
	self raw: BoldMarkup.
]]]

- The builder executes the block ==aBlock value==
- Here the implications is that there is only one builder (the message receiver eg, ==builder bold: [ builder text: 'Very']==

${slide:title=Comparing alternate designs}$

[[[
aBuilder header: [ :builder | builder text: 'Factory method' ] withLevel: 2.
]]]

[[[
aBuilder header: [ aBuilder text: 'Factory method' ] withLevel: 2.
]]]


${slide:title=No argument design}$

[[[
aBuilder header: [ aBuilder text: 'Factory method' ] withLevel: 2.
]]]

- Only the builder for all the messages
- More compact


${slide:title=No argument implementation}$

[[[
header: aBloc withLevel: anInteger
	self rawHeader: aBloc withLevel: anInteger.
	self newLine

rawHeader: aBloc withLevel: anInteger
	self raw: (HeaderMarkup repeat: anInteger).
   self raw: String space.
   aBloc value
]]]

${slide:title=Argument Design}$

[[[
aBuilder header: [ :builder | builder text: 'Factory method' ] withLevel: 2.
]]]

- Each API can have its owns  the builder 
- We can have an hierarchy of builder each one representing finer context
- More verbose


${slide:title=Argument implementation}$

[[[
rawHeader: aBloc withLevel: anInteger
	self raw: (HeaderMarkup repeat: anInteger).
	self raw: String space.
	aBloc value: SpecialMicrodownBuilder new
]]]

Each subclass can specialize ==rawHeader: aBloc withLevel: anInteger== to use a specific builder passed as argument of the ==value:==

${slide:title=Analysis}$

""Pros:""
- With an explicit argument builder, we can also subclass the builder and modify partially the builder behavior
-- We could have specialisation builder that produces table of contents
- It feels like visitor hooks

""Cons:""
- You have to define an extra parameter to all the wrapping APIs

