{
	"title":"About Fluid API",
	"subtitle":"The case of the class definition",
	"author":"S. Ducasse",
	"slidesid":"2022"
	
}


${slide:title=Goal}$

- Think modular
- Looking at the class definition printer
- Check design approach in Pharo 9



${slide:title=Context: Class Definition }$

- How to support the evolution of class definition
- Supporting package, various formats, slots
- Without parameter explosions

${slide:title=Historically: a Class Definition in ST-80}$

[[[
ArrayedCollection variableSubclass: #Array
	instanceVariableNames: ''''
	classVariableNames: ''''
	poolDictionaries: ''''
	category: ''Collections-Sequenceable-Base'''
]]]


${slide:title=Pharo up to Pharo 90}$

- Avoid spurious fields, but still...
- Supports package

[[[
ArrayedCollection variableSubclass: #Array
	instanceVariableNames: ''''
	classVariableNames: ''''
	package: ''Collections-Sequenceable-Base''
]]]

[[[
Object subclass: #Point
	instanceVariableNames: ''x y''
	classVariableNames: ''''
	package: ''Kernel-BasicObjects'''
]]]

${slide:title=Method Parameter Explosion}$

- Packages, tags, slots, 
- New kind of subclasses: ephemerons,....
- How to support new information without method parameter combinatory explosion





${slide:title=Using Fluid API}$

- Using a fluid API (cascade instead of mandatory parameters)
- Only the necessary parameters
- Composable
- Extensible
- Supporting complex slots (first class instance variables)

[[[

]]]


${slide:title=Example of Fluid API}$

[[[
	foo: aString bar: anotherString babar: aThirdString
]]]

becomes

[[[
	foo: aString;
	bar: anotherString;
	babar: aThirdString
]]]

or 

[[[
	babar: aThirdString;
	foo: aString
]]]

${slide:title=Fluid class definition in Pharo}$

[[[
ArrayedCollection << #Array
	layout: VariableLayout;
	tag: ''Base'';
	package: ''Collections-Sequenceable'''
]]]

[[[
Object class << Point class
	package: 'Kernel'
]]]

- Modular
- Compact
- Extensible

${slide:title=The Case of Complex Slots}$

- Previous Pharo class definition did not support well slots

[[[
SpAbstractWidgetPresenter << #SpDiffPresenter
	slots: {
			#showOptions => SpObservableSlot .
			#showOnlyDestination => SpObservableSlot .
			#showOnlySource => SpObservableSlot .
			#contextClass => SpObservableSlot .
			#leftLabel => SpObservableSlot .
			#leftText => SpObservableSlot .
			#rightLabel => SpObservableSlot .
			#rightText => SpObservableSlot };
		tag: 'Widgets';
		package: 'Spec2-Core'
]]]



${slide:title=Analysis of Fluid API}$

Pros:
- handles combinatorial explosion
- handles optional argument

Cons: 
- The order can be important
- Some messages (package:) have to be the last one.


${slide:title=Conclusion}$

- Fluid API is nice for large parameters for configuration

