{
    "title":"Reifying and delegating behavior",
    "subtitle":"",
    "author":"StÃ©phane Ducasse"
}


${slide:title=Goal}$

- Creating an object and delegating creates dispatch spaces
- From one kind of files to multiple kinds

${slide:title=Case study: Pillar managing .pillar file}$

- How to get a parsed document?

Long time ago
- We ask the parser!
- parser turns pillar file into document tree
- There was ONLY one parser associated to a document
- The idea was to avoid to hardcode everywhere PRParser
- Worked for trying different version of PetitParser parsers.

[[[
PRDocument parser parseFile: aFileReference
]]]


${slide:title=Case study: Pillar supports .pillar }$

[[[	
PRAbstractOutputDocument >> buildOn: aPRProject 
	
	| parsedDocument transformedDocument writtenFile |
	parsedDocument := self parseInputFile: file.
	parsedDocument properties: (self metadataConfigurationForDocument: parsedDocument).
	transformedDocument := self transformDocument: parsedDocument.
	writtenFile := self writeDocument: transformedDocument.
	self postWriteTransform: writtenFile.
	^ PRSuccess new.
]]]

[[[	
PRAbstractOutputDocument >> parseInputFile: anInputFile
	^ PRDocument parser parse: anInputFile file	
]]]

${slide:title=Problems}$

- Only one syntax
- Checks for the file extension were hardcoded
- Difficult to know if a file was part of a project (books)
- Access to project configuration (user option) was cumbersome

${slide:title=Solution: Introduced InputDocument}$

- First step: instead of manipulating files
- Manipulate InputDocument objects
- InputDocument wrap files and more information

${slide:title=Introduced the notion of InputDocument}$

[[[
PRBuilAllStrategy >> filesToBuildOn: aProject

	^ children flatCollect: [ :each |
		each allChildren
			select: [ :file | file isFile and: [ file extension = 'pillar' ] ]
			thenCollect: [ :file | 
				PRInputDocument new
					project: aProject;
					file: file;
					yourself ] ]
]]]

[[[			
PRInputDocument >> parser
	file extension = 'pillar'
		ifTrue: [ ^ PRDocument parser ].
	self error: 'No parser for document extension: ', file extension
]]]

${slide:title=PRInputDocument}$

- First step
- We do not distribute responsibility

[[[
... select: [ :file | file isFile and: [ file extension = 'pillar' ] ]
]]]

- Not modular


${slide:title=Support for .mic/.md files}$

- Now Pillar compilation chain should accept .md file
- Different syntax!
- Different parser!

${slide:title=Refining InputDocument into a Simple Hierarchy}$

- Different classes
- Move behavior to such classes

[[[
PRInputDocument << #PRPillarInputDocument
	package: 'Pillar-ExporterCore'
]]]

[[[
PRInputDocument << #PRMicrodownInputDocument
	package: 'Pillar-Microdown'
]]]

${slide:title= InputFile is responsible for its parser}$

[[[
PRAbstractOutputDocument >> parseInputFile: anInputFile	
	^ anInputFile parsedDocument
]]]

[[[
PRPillarInputDocument >> parsedDocument
	^ self parserClass parse: file
]]]

[[[
PRMicrodownInputDocument >> parsedDocument
	^ (self parserClass parse: file) asPillar
]]]


${slide:title=Registration mechanism to support modularity}$

- We need to create objects of the right kind
- Use a registration mechanism, so that input documents can declare their existence

[[[
PRInputDocument class >> inputClassForFile: aFile
	
	^ self subclasses
		detect: [ :each | each doesHandleExtension: aFile extension ]
		ifNone: [ PRNoInputDocument  ]
]]]

[[[		
PRPillarInputDocument >> doesHandleExtension: anExtension
	^ anExtension = 'pillar'		
]]]

[[[
PRMicrodownInputDocument >> doesHandleExtension: anExtension
	^ anExtension = 'mic'
]]]

${slide:title=Creating the right kind of InputDocument objects}$

[[[
PRBuilAllStrategy >> filesToBuildOn: aProject

	^ files collect: [ :file | 
		(PRInputDocument inputClassForFile: file asFileReference) new
			project: aProject;
			file: (aProject baseDirectory resolve: file);
			yourself ]
]]]

${slide:title=Conclusion}$

- Turning implicit into an object
- Turning one object into objects of different but polymorphic classes
- Moving behavior to be able to delegate 
- Using registration to create modular design




