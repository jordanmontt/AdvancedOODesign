{
    "title" : "Stone Paper Scissors",
    "slidesid" : "with Double Dispatch",
    "author" : ""
}

${slide:title=Goals}$

- In the quest of dispatch
- No conditionals!

[[[
(Stone new vs: Paper new)
>>> #paper
]]]


${slide:title=Stone Paper Scissors: one Test}$

[[[
StonePaperScissorsTest >> testPaperIsWinning
	self assert: (Stone new vs: Paper new) equals: #paper
]]]

${slide:title=Stone Paper Scissors via Tests}$

[[[
StonePaperScissorsTest >> testPaperIsWinning
	self assert: (Stone new vs: Paper new) equals: #paper
]]]

[[[
StonePaperScissorsTest >> testStoneAgainsStone
	self assert: (Stone new vs: Stone new) equals: #draw
]]]

[[[
StonePaperScissorsTest >> testStoneIsWinning
	self assert: (Stone new vs: Scissors new) equals: #stone
]]]





${slide:title=Let us start}$

[[[
StonePaperScissorsTest >> testPaperIsWinning
	self assert: (Stone new vs: Paper new) equals: #paper
]]]

[[[
Stone >> vs: anotherTool
	^ ...
]]]


${slide:title=Hints}$

- Solution does not contain an explicit condition
- Remember sending a message is making a choice
- Sending a message is selecting the right method
- What if we introduce another method?

${slide:title= Paper playAgainstStone: }$

[[[
StonePaperScissorsTest >> testPaperIsWinning
	self assert: (Stone new vs: Paper new) equals: #paper
]]]

[[[
Stone >> vs: anotherTool
	^ anotherTool playAgainstStone: self
]]]

[[[
Paper >> playAgainstStone: aStone
	...
]]]

${slide:title= Paper playAgainstStone: }$

[[[
StonePaperScissorsTest >> testPaperIsWinning
	self assert: (Stone new vs: Paper new) equals: #paper
]]]

[[[
Stone >> vs: anotherTool
	^ anotherTool playAgainstStone: self
]]]

[[[
Paper >> playAgainstStone: aStone
>> ^ #paper
]]]



${slide:title=Other playAgainstStone: }$

[[[
Scissors >> playAgainstStone: aStone
	^ #stone
]]]

[[[
Stone >> playAgainstStone: aStone
	^ #draw
]]]


${slide:title=Scissors now }$

[[[
StonePaperScissorsTest >> testScissorsIsWinning
	self assert: (Scissors new vs: Paper new) = #scissors
]]]

[[[
Scissors >> vs: anotherTool
	^ anotherTool playAgainstScissors: self
]]]

[[[
Scissors >> playAgainstScissors: aScissors
	^ #draw
]]]

[[[
Paper >> playAgainstScissors: aScissors
	^ #scissors
]]]

[[[
Stone >> playAgainstScissors: aScissors
	^ #stone
]]]

${slide:title=Paper now }$
[[[
Paper >> vs: anotherTool
	^ anotherTool playAgainstPaper: self
]]]

[[[
Scissors >> playAgainstPaper: aPaper
	^ #scissors
]]]

[[[
Paper >> playAgainstPaper: aPaper
	^ #draw
]]]

[[[
Stone >> playAgainstPaper: aPaper
	^ #paper
]]]

${slide:title=Overview}$

+An overview of a possible solution using double dispatch.>file://figures/StonePaperScissors.pdf|width=80+

${slide:title=Remark}$

In this example we do not need to pass the argument during the double dispatch

[[[
Scissors >> playAgainstPaper: aPaper
	^ #scissors
]]]

[[[
Scissors >> playAgainstPaper
	^ #scissors
]]]






${slide:title=Thinking more...}$

When we return a token or a number we should check to do something after.
So passing blocks may be better.

[[[
Paper new competeWith: Paper new
	onDraw: [ Game incrementDraw ]
	onReceiverWin: [ ]
	onReceiverLose: [ ]
]]]

${slide:title=Conclusion}$

- Powerful
- Modular
- Just sending an extra message to an argument and using late binding
