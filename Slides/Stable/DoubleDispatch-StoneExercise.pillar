{
    "title" : "Stone Paper Scissors",
    "slidesid" : "with Double Dispatch",
    "author" : ""
}

${slide:title=Goals}$

- In the quest of dispatch
- No conditionals!

[[[
(Stone new vs: Paper new)
>>> #paper
]]]

${slide:title=Goals}$

+Stone Paper Scissors.>file://figures/StonePaperScissorsGame.pdf|width=80+

${slide:title=Stone Paper Scissors: one Test}$

[[[
StonePaperScissorsTest >> testPaperIsWinning
	self assert: (Stone new vs: Paper new) equals: #paper
]]]

${slide:title=The inverse too}$

[[[
StonePaperScissorsTest >> testPaperIsWinning
	self assert: (Stone new vs: Paper new) equals: #paper
]]]

[[[
StonePaperScissorsTest >> testPaperIsWinning
	self assert: (Paper new vs: Stone new) equals: #paper
]]]

${slide:title=More Tests}$

[[[
StonePaperScissorsTest >> testStoneAgainsStone
	self assert: (Stone new vs: Stone new) equals: #draw
]]]

[[[
StonePaperScissorsTest >> testStoneIsWinning
	self assert: (Stone new vs: Scissors new) equals: #stone
]]]





${slide:title=Let us start}$

[[[
StonePaperScissorsTest >> testPaperIsWinning
	self assert: (Stone new vs: Paper new) equals: #paper
]]]

[[[
Stone >> vs: anotherTool
	^ ...
]]]


${slide:title=Hints}$

- The solution does not contain an explicit condition
- Remember sending a message is making a choice
- Sending a message is selecting the right method
-- when we send the message ==vs:== the method of the receiver is executed
- What if we introduce another method?

${slide:title= Paper playAgainstStone: }$

[[[
Stone >> vs: anotherTool
	^ anotherTool playAgainstStone: self
]]]

[[[
Paper >> playAgainstStone: aStone
	^ ...
]]]

${slide:title= Paper playAgainstStone: }$

[[[
Stone >> vs: anotherTool
	^ anotherTool playAgainstStone: self
]]]

[[[
Paper >> playAgainstStone: aStone
>> ^ #paper
]]]

${slide:title= Paper playAgainstStone: }$

Works for 
[[[
Stone new vs: Paper new
>>> #paper
]]]

But not for 

[[[
Stone new vs: Scissor new
>>> #stone
]]]

- How to fix this?
- Easy!


${slide:title=Other playAgainstStone: }$

[[[
Scissors >> playAgainstStone: aStone
	^ #stone
]]]

[[[
Stone >> playAgainstStone: aStone
	^ #draw
]]]


${slide:title=Stepping back}$

- We know that a method is executed on a class (here ==Stone==)
- We SEND another message to the argument to select another method (here ==playAgainstStone:==)
- We sent two messages to be able to select a method based on its receiver AND argument






${slide:title=Scissors now }$

[[[
Scissors >> vs: anotherTool
	^ anotherTool playAgainstScissors: self
]]]

[[[
Scissors >> playAgainstScissors: aScissors
	^ #draw
]]]

[[[
Paper >> playAgainstScissors: aScissors
	^ #scissors
]]]

[[[
Stone >> playAgainstScissors: aScissors
	^ #stone
]]]

${slide:title=Paper now }$
[[[
Paper >> vs: anotherTool
	^ anotherTool playAgainstPaper: self
]]]

[[[
Scissors >> playAgainstPaper: aPaper
	^ #scissors
]]]

[[[
Paper >> playAgainstPaper: aPaper
	^ #draw
]]]

[[[
Stone >> playAgainstPaper: aPaper
	^ #paper
]]]

${slide:title=Solution Overview}$

+An overview of a possible solution using double dispatch.>file://figures/StonePaperScissorsAndKey.pdf|width=80+

${slide:title=Remark}$

- In this toy example we do not need to pass the argument during the double dispatch
- But in general this is important as in Visitor

[[[
Scissors >> playAgainstPaper: aPaper
	^ #scissors
]]]

can just be

[[[
Scissors >> playAgainstPaper
	^ #scissors
]]]

${slide:title=Remark}$

+.>file://figures/StonePaperScissorsNoParameters.pdf|width=80+


${slide:title=Extending it...}$

+>file://figures/StonePaperScissorsLizzardSpockGame.pdf|width=80+

${slide:title=Conclusion}$

- Powerful
- Modular
- Just sending an extra message to an argument and using late binding
