{
    "title":"Thinking about Coupling",
    "slidesid":"",
    "author":"",
    "subtitle":""
}


${slide:title=Goal}$

- Think about Coupling
- Law of Demeter 
- Better seen as a Heuristic


${slide:title=Coupling is costly}$

- ""Reuse:"" I cannot reuse this component in another application
- ""Substition:"" I cannot easily substitute this part for another one
- ""Encapsulation:"" when a change far away happens, I get impacted

${slide:title=Core of the Problem}$

+.>file://figures/LODCoreProblem.pdf|width=100+


${slide:title=Changes}$

- Changes are natural
- When you change, your dependent should update
- The problem is waves of changes when dependent of dependent should change

+.>file://figures/LODCoreProblem.pdf|width=100+

${slide:title=Waves}$

- Waves are created by leak of references to far objects
- Basically violation of encapsulation
- How to limit wave creation?
- Do not leak far references!


${slide:title=Law of Demeter}$

You should only send messages to: 
- an argument passed to you
- instance variables
- an object you create
- self, super your class

You should avoid
- global variables
- objects returned from message sends other than self

${slide:title=Only talk to your immediate friends}$

[[[
someMethod: aParameter 
	self foo.
	super someMethod: aParameter.
	self class foo.
	self instVarOne foo.
	instVarOne foo.
	aParameter foo.
	thing := Thing new.
	thing foo
]]]

${slide:title=Don't skip your intermediates}$

+.>file://figures/LODSkip.pdf|width=80+


${slide:title=Solution: Respect encapsulation}$

+.>file://figures/LODSkipSol.pdf|width=80+


${slide:title=Transformation}$

+.>file://figures/LODtransformation.pdf|width=70+


${slide:title=Real example}$

[[[
OSWindowMorphicEventHandler >> visitWindowResolutionChangeEvent: anEvent
	"Resolution (dpi) changed. For now just check for a new size."
	"We need to reset the render if the resolution changes."

	morphicWorld worldState worldRenderer window backendWindow renderer destroy.
	morphicWorld worldState worldRenderer window backendWindow renderer validate.
	morphicWorld worldState doFullRepaint.
	morphicWorld worldState worldRenderer window backendWindow renderer updateAll.
	morphicWorld worldState worldRenderer checkForNewScreenSize
]]]


${slide:title=Solution}$

[[[
OSWindowMorphicEventHandler >> visitWindowResolutionChangeEvent: anEvent
	morphicWorld worldState updateToNewResolution: anEvent
]]]

[[[
WorldState >> updateToNewResolution: originalEvent
	"We need to reset the render if the resolution changes."

	self doFullRepaint.
	self worldRenderer updateToNewResolution.
	self worldRenderer checkForNewScreenSize
]]]


[[[
OSSDL2BackendWindow >> updateToNewResolution
	"Force the regeneration of the renderer because we have a new resolution"
	renderer destroy.
	renderer validate.
	renderer updateAll.
]]]

[[[
NullWorldRenderer >> updateToNewResolution
	self
]]]

${slide:title=LOD is a \*\*heuristic\*\*}$

- Pay attention! A too strict application of the LOD can lead to over engineered design
- Encapsulating collections may produce large interfaces so not applying the LoD may help
- Understand when it is reasonable to leak

${slide:title=LOD can produce bloated APIs}$

[[[
Object subclass: #FMMethods 
	instVar: 'senders'
	...
]]]

[[[
FMMethods >> do: aBlock
	senders do: aBlock
FMMethods >> collect: aBlock
	^ senders collect: aBlock
FMMethods >> select: aBlock
	^ senders select: aBlock
FMMethods >> detect: aBlock
	^ senders detect: aBlock
FMMethods >> isEmpty
	^ senders isEmpty
...
]]]


${slide:title=Conclusion}$

- Think about impact of changes
- Avoid chaining messages
- Law of Demeter is a heuristic

