{
    "title":"Command Design Pattern",
    "author":"S. Ducasse"
}

${slide:title=Goals}$

- Little motivation
- Power of reification of actions
- Command Design Pattern
- Glimpse at Commander


${slide:title=Imagine a scriptable robot}$

[[[
testExecute
	| rb b |
	rb := RbsRobot new.
	rb startLocation: 4@1.
	rb execute: 
'dir #east
mov 2
mov 3
dir #north
mov 3'.
	self assert: rb position equals: 9@4
]]]


${slide:title=Execute (first version)}$


[[[
RbsRobot >> execute: aString

	orders := aString splitOn: Character cr.
	orders := orders collect: [ :each | each splitOn: Character space ].
	orders do: [ :each |
		each first = 'mov'
			ifTrue: [ self move: (Object readFrom: each second) ]
			ifFalse: [ each first = 'dir'
							ifTrue: [ self direction: (Object readFrom: each second) ] ] ]
]]]

${slide:title=Execute (more actions)}$

[[[
RbsRobot >> execute: aString

	orders := aString splitOn: Character cr.
	orders := orders collect: [ :each | each splitOn: Character space ].
	orders do: [ :each |
		each first = 'mov'
			ifTrue: [ self move: (Object readFrom: each second) ]
			ifFalse: [ each first = 'dir'
							ifTrue: [ self direction: (Object readFrom: each second) ]
							ifFalse: [ each first = 'drop' ]]
							...
							each first = 'pick'
							...
							each first = 'return' ]
]]]



${slide:title=Analysis}$

- Each time we want to add a new order we will have to change ==execute:==
- Imagine that executing a ==mov== order cost a lot and that it is better to have one long over small ones
-- ==mov 10 mov 10== -> ==mov 20==
-- Not simple to perform a simple path optimization
- How to replay the exact low-level executions
- Imgine writing an Undo for each command


${slide:title=Commands}$

- A command is a reification of order/action
- A command encapsulates an action and optionally its context
-- menu item
-- log action
- Commands are often the basis for Undo


${slide:title=Command core}$

+>file://figures/DPCommand.pdf|width=85+



${slide:title=Robot command: direction}$

[[[
RbsCommand << #RbsDirectionCommand
	slots: { #direction };
	tag: 'Commands';
	package: 'Robots'
]]]

[[[
RbsDirectionCommand << handleArguments: aCollection
	direction := aCollection first asSymbol

RbsDirectionCommand << executeOn: aRobot
	aRobot direction: direction
]]]

${slide:title=Robot command: move}$

[[[
RbsCommand << #RbsMoveCommand
	slots: { #distance };
	tag: 'Commands';
	package: 'Robots'
]]]

[[[
RbsMoveCommand << handleArguments: aCollection
	direction := Object readFrom: aCollection first
	
RbsMoveCommand << executeOn: aRobot
	aRobot move: distance
]]]


${slide:title=Changing the execute logic}$


[[[
RbsRobot >> executeCommandBased: aString

	orders := aString splitOn: Character cr.
	orders := orders collect: [ :each | each splitOn: Character space ].
	orders do: [ :each |
			(self commandClassFor: each first) new
				handleArguments: each allButFirst;
				executeOn: self ]
]]]

${slide:title=Analysis of extensibility in place}$


+>file://figures/RbsCommand.pdf|width=55+

- Each command is responsible for handling its own data
- Each command encapsulates its state, applicability and action
- We can now manipulate actions
-- imagine implementing a replay or a back to home


${slide:title=Command cons}$

- Not all operations should be turned into Command objects
- Produce large hierarchies of simple classes



${slide:title=Commander}$

+>file://figures/withMenus.png|width=25+

In Pharo Commander is a little framework for commands
- Can produce a toolbar or menus
- UI is optional

[[[
(EgAddContactCommand new context: aPresenter) execute
]]]


${slide:title=Core commander}$

+>file://figures/FirstDecorator.pdf|width=70+


${slide:title=Add Contact}$

[[[
EgContactBookCommand << #EgAddContactCommand
	package: 'EgContactBook'
]]]

[[[
CmAddContactCommand >> initialize
	super initialize.
	self
		basicName: 'New contact';
		basicDescription: 'Creates a new contact and add it to the contact
book.'
]]]

${slide:title=Add Contact: Behavior}$

[[[
CmAddContactCommand >> execute
	| contact |
	contact := self contactBookPresenter newContact.
	self hasSelectedContact
		ifTrue: [ self contactBook
					addContact: contact
					after: self selectedContact ]
		ifFalse: [ self contactBook addContact: contact ].
	self contactBookPresenter updateView
]]]



${slide:title=Commander and its decorators}$

+>file://figures/DecoratorWithSpec2.pdf|width=75+


${slide:title=Commander and its decorators}$
[[[
CmCommand >> asSpecCommand
	"Subclasses might override this method to define default icon and shortcut."
	^ self decorateWith: SpCommand
]]]

[[[
StCommand >> asSpecCommand

	| command |
	command := super asSpecCommand 
		iconProvider: self application;
		iconName: self class defaultIconName;
		yourself.
	self class defaultShortcut 
		ifNotNil: [ :keyCombination | command shortcutKey: keyCombination ].
	^ command
]]]


${slide:title=One Command}$

[[[
StCommand << StPlaygroundDoItCommand 
	package: 'NewTools-Playground'
]]]

[[[
StCommand >> execute 
	context doEvaluateAllAndGo
]]]

${slide:title=Conclusion}$

- Commands are first class actions
- Adapted for manipulation of actions (Undo, replay)


